<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Arbitrum Triangular Arbitrage – v9.9.63</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:#0b0f14; color:#e6edf3; margin:0; }
    header { padding:16px 20px; background:#111826; border-bottom:1px solid #1f2937; display:flex; align-items:center; gap:12px; }
    h1 { font-size:18px; margin:0; }
    main { display:grid; grid-template-columns: 320px 1fr; gap:16px; padding:16px; }
    .card { background:#0f1722; border:1px solid #1f2937; border-radius:10px; }
    .card h3 { margin:0; padding:12px 14px; border-bottom:1px solid #1f2937; font-size:14px; color:#9ab; }
    .card .body { padding:12px 14px; }
    input, select, button, textarea {
      font: inherit; background:#0c121b; color:#e6edf3; border:1px solid #223045; border-radius:8px; padding:8px 10px;
    }
    input:focus, select:focus, button:focus, textarea:focus { outline: none; border-color:#3b82f6; box-shadow:0 0 0 2px rgba(59,130,246,.25); }
    button { cursor:pointer; }
    .grid { display:grid; gap:10px; }
    .row { display:flex; gap:8px; align-items:center; }
    .small { font-size:12px; color:#9ab; }
    .muted { color:#7c8ea3; }
    .pill { padding:2px 8px; border:1px solid #243246; border-radius:999px; font-size:12px; color:#b7c6d9;}
    .warn { color:#fbbf24; }
    .err  { color:#f87171; }
    .ok   { color:#34d399; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    #log { height: 45vh; resize: vertical; }
    table { width:100%; border-collapse: collapse; }
    th, td { border-bottom:1px solid #1f2937; padding:6px 8px; font-size:13px; }
    th { text-align:left; color:#9ab; position:sticky; top:0; background:#0f1722; }
    .right { text-align:right; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
</head>
<body>
<header>
  <h1>Arbitrum Triangular Arbitrage <span class="pill">v9.9.63</span></h1>
  <span class="small muted">SushiV2 + CamelotV2 + UniV3 (Quoter)</span>
</header>

<main>
  <section class="card">
    <h3>Controls</h3>
    <div class="body grid">
      <div class="grid">
        <label class="small">Wallet / RPC</label>
        <div class="row">
          <button id="btnConnect">Connect MetaMask</button>
          <select id="rpcSel" title="RPC">
            <option value="alchemy">Alchemy (hardwired)</option>
            <option value="metamask">Use MetaMask Provider</option>
          </select>
        </div>
        <div class="small muted" id="connInfo">Not connected</div>
      </div>

      <div class="grid">
        <label class="small">Parameters</label>
        <div class="row">
          <label class="small">Tokens</label>
          <input id="tokenCount" type="number" value="120" min="10" step="10" style="width:90px"/>
          <span class="small muted">auto-discovered on load</span>
        </div>
        <div class="row">
          <label class="small">Loan (WETH)</label>
          <input id="loan" type="number" value="10" step="0.5" style="width:110px"/>
          <span class="small muted">for profit calc only</span>
        </div>
        <div class="row">
          <label class="small">Probe (WETH)</label>
          <input id="probe" type="number" value="0.001" step="0.001" style="width:110px"/>
          <span class="small muted">smaller = find edges</span>
        </div>
        <div class="row">
          <label class="small">Premium</label>
          <input id="premiumBps" type="number" value="5" step="1" style="width:90px"/>
          <span class="small muted">bps (e.g. 5 = 0.05%)</span>
        </div>
        <div class="row">
          <label class="small">Gas (gwei)</label>
          <input id="gasGwei" type="number" value="0.35" step="0.01" style="width:90px"/>
          <span class="small muted">arb avg low</span>
        </div>
      </div>

      <div class="row">
        <button id="btnScan">Scan</button>
        <button id="btnDiscover">Re-Discover Tokens</button>
        <span id="scanStatus" class="small muted">Ready.</span>
      </div>
    </div>
  </section>

  <section class="card" style="min-height:60vh;">
    <h3>Results</h3>
    <div class="body">
      <table id="resTable">
        <thead>
          <tr>
            <th>#</th>
            <th>Token</th>
            <th>Path</th>
            <th class="right">Back (WETH)</th>
            <th class="right">Net (WETH)</th>
            <th class="right">Net ($)</th>
            <th>Route Type</th>
            <th>Note</th>
          </tr>
        </thead>
        <tbody id="resBody"></tbody>
      </table>
    </div>
  </section>

  <section class="card">
    <h3>Log</h3>
    <div class="body">
      <textarea id="log" class="mono" spellcheck="false"></textarea>
    </div>
  </section>
</main>

<script>
(async function() {
  // ---------- Constants (Arbitrum) ----------
  const ALCHEMY_URL = "https://arb-mainnet.g.alchemy.com/v2/h4YaGX9cc_WywAx5cvsez"; // your hardwired key
  const WETH = "0x82aF49447D8a07e3BD95BD0d56f35241523fBab1";
  const SUSHI_ROUTER = "0x1b02da8cb0d097eb8d57a175b88c7d8b47997506";
  const CAMELOT_ROUTER = "0xC873FECbD354f5A56E00E710B90EF4201Db2448d";
  const UNIV3_QUOTER = "0x61fFE014bA17989E743c5F6cB21bF9697530B21e";

  // common stables
  const USDC = "0xaf88d065e77c8cc2239327c5edb3a432268e5831";
  const USDCE= "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8";

  // ABI fragments
  const IUniswapV2Router = [
    "function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts)"
  ];
  const IUniswapV3Quoter = [
    "function quoteExactInputSingle(address tokenIn, address tokenOut, uint24 fee, uint256 amountIn, uint160 sqrtPriceLimitX96) external returns (uint256 amountOut)"
  ];

  // fee tiers to try for UniV3
  const V3_FEES = [500, 3000, 10000]; // 0.05%, 0.3%, 1%

  // State
  let provider, signer, account;
  const $ = s => document.querySelector(s);
  const logEl = $("#log");
  const resBody = $("#resBody");
  const scanStatus = $("#scanStatus");
  const tokenSet = new Map(); // symbol -> address

  // ---------- Helpers ----------
  const fmt = n => Number(n).toLocaleString(undefined, { maximumFractionDigits: 6 });
  const fmt4 = n => Number(n).toLocaleString(undefined, { maximumFractionDigits: 4 });
  const usd = n => Number(n).toLocaleString(undefined, { style:"currency", currency:"USD", maximumFractionDigits:2 });

  function log(line) {
    logEl.value += (logEl.value ? "\n" : "") + line;
    logEl.scrollTop = logEl.scrollHeight;
  }

  function setStatus(text) {
    scanStatus.textContent = text;
  }

  function addToken(symbol, address) {
    if (!address) return;
    const key = symbol.trim().toUpperCase();
    if (!tokenSet.has(key)) tokenSet.set(key, ethers.utils.getAddress(address));
  }

  function skipIdentical(a, b) {
    return ethers.utils.getAddress(a) === ethers.utils.getAddress(b);
  }

  function calcCosts(loanWeth, premiumBps, gasGwei) {
    // crude approximate costs (no flash executor yet)
    const premium = loanWeth * (premiumBps / 10000); // in WETH
    const gasEth = (Number(gasGwei) * 1e-9) * 450000; // rough 450k gas for tri swap (view only signal)
    return { premium, gasEth };
  }

  function estUsdPerWeth() {
    // quick static approx to avoid another onchain call; adjust if needed
    return 3000; // adjust if you want
  }

  // ---------- Providers ----------
  function makeProvider(kind) {
    if (kind === "metamask" && window.ethereum) {
      return new ethers.providers.Web3Provider(window.ethereum);
    }
    return new ethers.providers.JsonRpcProvider(ALCHEMY_URL);
  }

  async function connectWallet() {
    try {
      if (!window.ethereum) throw new Error("MetaMask not found");
      await window.ethereum.request({ method: "eth_requestAccounts" });
      const web3 = new ethers.providers.Web3Provider(window.ethereum);
      const net = await web3.getNetwork();
      if (String(net.chainId) !== "42161") {
        log("[WARN] Switch MetaMask to Arbitrum One (42161).");
      }
      provider = $("#rpcSel").value === "metamask" ? web3 : new ethers.providers.JsonRpcProvider(ALCHEMY_URL);
      signer = provider.getSigner();
      account = await signer.getAddress();
      $("#connInfo").textContent = `Connected: ${account.slice(0,6)}…${account.slice(-4)}`;
      log("Wallet connected.");
    } catch (e) {
      log(`[ERR] connect: ${e.message}`);
    }
  }

  // ---------- DEX Clients ----------
  const sushi = new ethers.Contract(SUSHI_ROUTER, IUniswapV2Router, () => provider);
  const camelot = new ethers.Contract(CAMELOT_ROUTER, IUniswapV2Router, () => provider);
  const quoter = new ethers.Contract(UNIV3_QUOTER, IUniswapV3Quoter, () => provider);

  async function v2Quote(router, amountIn, path) {
    try {
      if (path.length < 2) return null;
      // guard identical path (causes IDENTICAL_ADDRESSES revert)
      for (let i = 1; i < path.length; i++) {
        if (skipIdentical(path[i-1], path[i])) return null;
      }
      const amounts = await router.getAmountsOut(amountIn, path);
      return amounts[amounts.length - 1];
    } catch (e) {
      return { __error: e };
    }
  }

  async function v3QuoteSingle(tokenIn, tokenOut, fee, amountIn) {
    try {
      if (skipIdentical(tokenIn, tokenOut)) return null;
      // *** IMPORTANT FIX: positional args, not a struct ***
      const amountOut = await quoter.quoteExactInputSingle(
        tokenIn,
        tokenOut,
        fee,
        amountIn,
        0 // sqrtPriceLimitX96
      );
      return amountOut;
    } catch (e) {
      return { __error: e };
    }
  }

  // Try V2 pairs and V3 fees for WETH<->TOKEN round trip
  async function roundTrip(tokenAddr, probeWei, sym) {
    const routes = [];

    // ----- V2 routes (Sushi <-> Camelot): WETH -> TOKEN -> WETH
    // SUSHI then CAMELOT
    routes.push({ name:"SUSHI v2 → CAMELOT v2", exec: async () => {
      const out1 = await v2Quote(sushi, probeWei, [WETH, tokenAddr]);
      if (out1 && out1.__error) throw out1.__error;

      const out2 = await v2Quote(camelot, out1, [tokenAddr, WETH]);
      if (out2 && out2.__error) throw out2.__error;

      return out2;
    }});
    // CAMELOT then SUSHI
    routes.push({ name:"CAMELOT v2 → SUSHI v2", exec: async () => {
      const out1 = await v2Quote(camelot, probeWei, [WETH, tokenAddr]);
      if (out1 && out1.__error) throw out1.__error;

      const out2 = await v2Quote(sushi, out1, [tokenAddr, WETH]);
      if (out2 && out2.__error) throw out2.__error;

      return out2;
    }});

    // ----- V3 routes: try fee tiers for each leg
    for (const fA of V3_FEES) {
      for (const fB of V3_FEES) {
        routes.push({ name:`UniV3 ${fA/10000}% → ${fB/10000}%`, exec: async () => {
          const out1 = await v3QuoteSingle(WETH, tokenAddr, fA, probeWei);
          if (out1 && out1.__error) throw out1.__error;

          const out2 = await v3QuoteSingle(tokenAddr, WETH, fB, out1);
          if (out2 && out2.__error) throw out2.__error;

          return out2;
        }});
      }
    }

    // Run all and collect best
    let best = null;
    const notes = [];
    for (const r of routes) {
      try {
        const back = await r.exec();
        if (!back) continue;
        if (!best || back.gt(best.back)) best = { name:r.name, back };
      } catch (e) {
        notes.push(`${r.name} fail: ${shortErr(e)}`);
      }
    }

    return { best, notes };
  }

  function shortErr(e) {
    const msg = (e && e.message) ? e.message : String(e);
    // make logs shorter
    if (msg.includes("CALL_EXCEPTION")) return "call exception";
    if (msg.includes("execution reverted")) return "execution reverted";
    if (msg.includes("IDENTICAL_ADDRESSES")) return "IDENTICAL_ADDRESSES";
    if (msg.includes("INSUFFICIENT_LIQUIDITY")) return "INSUFFICIENT_LIQUIDITY";
    if (msg.includes("cannot encode object")) return "encode error";
    return msg.slice(0, 120);
  }

  // ---------- Auto-discover tokens (DexScreener) ----------
  async function discoverTokens(limit=120) {
    try {
      setStatus("Discovering tokens…");
      log(`[${time()}] Discovering top pairs from DexScreener…`);

      // Pull multiple pages to get ~150 tokens (unique)
      const pages = [
        "https://api.dexscreener.com/latest/dex/pairs/arbitrum",
        "https://api.dexscreener.com/latest/dex/pairs/arbitrum?page=2",
        "https://api.dexscreener.com/latest/dex/pairs/arbitrum?page=3"
      ];

      const seen = new Set([WETH.toLowerCase()]);
      // Always seed a few majors
      addToken("WETH", WETH);
      addToken("USDC", USDC);
      addToken("USDC.e", USDCE);

      for (const url of pages) {
        const res = await fetch(url);
        if (!res.ok) continue;
        const data = await res.json();
        if (!data || !data.pairs) continue;

        for (const p of data.pairs) {
          const t0 = p.baseToken, t1 = p.quoteToken;
          // prefer tokens paired with WETH or stables
          const preferred = [WETH.toLowerCase(), USDC.toLowerCase(), USDCE.toLowerCase()];
          const a0 = (t0 && t0.address || "").toLowerCase();
          const a1 = (t1 && t1.address || "").toLowerCase();
          const sym0= (t0 && t0.symbol || "").toUpperCase();
          const sym1= (t1 && t1.symbol || "").toUpperCase();

          // keep unique by address, avoid LPs / nulls
          const good0 = a0 && !seen.has(a0) && a0 !== "0x0000000000000000000000000000000000000000";
          const good1 = a1 && !seen.has(a1) && a1 !== "0x0000000000000000000000000000000000000000";

          const prefer0 = good0 && (preferred.includes(a1) || sym0==="WETH");
          const prefer1 = good1 && (preferred.includes(a0) || sym1==="WETH");

          if (prefer0) { addToken(sym0 || a0.slice(0,6), a0); seen.add(a0); }
          if (prefer1) { addToken(sym1 || a1.slice(0,6), a1); seen.add(a1); }

          if (tokenSet.size >= limit) break;
        }
        if (tokenSet.size >= limit) break;
      }

      setStatus(`Discovered ${tokenSet.size} tokens.`);
      log(`Discovered ${tokenSet.size} tokens.`);
      return tokenSet.size;
    } catch (e) {
      log(`[ERR] discoverTokens: ${e.message}`);
      return tokenSet.size;
    }
  }

  // ---------- Scan ----------
  function time(){ const d=new Date(); return d.toTimeString().slice(0,8); }

  function row(i, sym, route, backWeth, netWeth, netUsd, note) {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${i}</td>
      <td>${sym}</td>
      <td>${route || "-"}</td>
      <td class="right">${backWeth != null ? fmt4(backWeth) : "-"}</td>
      <td class="right ${netWeth>0?'ok':(netWeth<0?'err':'')}">${netWeth != null ? fmt4(netWeth) : "-"}</td>
      <td class="right ${netUsd>0?'ok':(netUsd<0?'err':'')}">${netUsd != null ? usd(netUsd) : "-"}</td>
      <td>${route && route.startsWith("UniV3") ? "V3" : (route ? "V2" : "-")}</td>
      <td class="small muted">${note || ""}</td>
    `;
    resBody.appendChild(tr);
  }

  async function scan() {
    resBody.innerHTML = "";
    const nWant = Math.max(10, Number($("#tokenCount").value)|0);
    const loanWeth = Number($("#loan").value);
    const probeWeth = Number($("#probe").value);
    const premiumBps = Number($("#premiumBps").value);
    const gasGwei = Number($("#gasGwei").value);
    const usdPerW = estUsdPerWeth();

    const { premium, gasEth } = calcCosts(loanWeth, premiumBps, gasGwei);
    const costWeth = premium + gasEth;

    const all = Array.from(tokenSet.entries())
      .filter(([sym, addr]) => addr && addr.toLowerCase() !== WETH.toLowerCase())
      .slice(0, nWant);

    log(`Ready.\n[${time()}] CLICK Scan; tokens=${all.length}; loan=${loanWeth.toLocaleString()}; probe=${probeWeth} WETH`);
    setStatus(`Scanning ${all.length} tokens…`);

    const probeWei = ethers.utils.parseEther(String(probeWeth));
    let i=0;

    for (const [sym, addr] of all) {
      i++;
      log(`${sym}: quoting Sushi/Camelot/UniV3…`);
      let bestBack = null, bestName = null, errs = [];

      try {
        const { best, notes } = await roundTrip(addr, probeWei, sym);
        errs = notes || [];
        if (best && best.back) {
          bestBack = Number(ethers.utils.formatEther(best.back));
          bestName = best.name;
        }
      } catch (e) {
        errs.push(shortErr(e));
      }

      if (bestBack == null) {
        row(i, sym, null, null, null, null, errs.join(" | "));
        continue;
      }

      // net calc at probe scale, then scale linearly to loan size (same % edge)
      const edgeWeth = bestBack - probeWeth; // gross edge at probe
      const estEdgePct = edgeWeth / probeWeth;
      const estBackAtLoan = loanWeth * (1 + estEdgePct);
      const netWeth = estBackAtLoan - loanWeth - costWeth;
      const netUsd = netWeth * usdPerW;

      row(i, sym, bestName, bestBack, netWeth, netUsd, errs.join(" | "));
    }

    setStatus("Done.");
  }

  // ---------- UI Events ----------
  $("#btnConnect").addEventListener("click", connectWallet);
  $("#btnScan").addEventListener("click", scan);
  $("#btnDiscover").addEventListener("click", async () => {
    await discoverTokens(Number($("#tokenCount").value)|0);
  });

  $("#rpcSel").addEventListener("change", () => {
    provider = makeProvider($("#rpcSel").value);
    log(`RPC switched to: ${$("#rpcSel").value}`);
  });

  // ---------- Boot: provider + auto-discover ----------
  provider = makeProvider($("#rpcSel").value);
  // seed a few we absolutely want
  addToken("WETH", WETH);
  addToken("USDC", USDC);
  addToken("USDC.e", USDCE);

  // auto-discover on load
  await discoverTokens(Number($("#tokenCount").value)|0);
  setStatus("Ready.");
  log("Auto-discovery complete. You can Scan now.");
})();
</script>
</body>
</html>
