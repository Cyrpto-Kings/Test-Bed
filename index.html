<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Crypto Kings Test Bed v8.5.0 — All-Token Scanner (Local)</title>
<style>
  :root { --bg:#0b0d12; --ink:#e8eef9; --muted:#9aa3af; --brand:#7c5cff; --ring:rgba(124,92,255,.35); --ok:#34d399; --warn:#f59e0b; --bad:#ef4444; }
  *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--ink);font:15px/1.45 system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .topbar{position:sticky;top:0;z-index:40;background:#0c0f1a;border-bottom:1px solid rgba(255,255,255,.08)}
  .topbar-inner{max-width:1200px;margin:0 auto;display:flex;align-items:center;gap:12px;padding:12px 16px}
  .logo{width:32px;height:32px;border-radius:8px;background:linear-gradient(135deg,#7c5cff,#1d9bf0);display:flex;align-items:center;justify-content:center;box-shadow:0 6px 20px rgba(29,155,240,.25)}
  .logo span{font-size:14px;font-weight:900;color:white}
  .brand{font-weight:800;letter-spacing:.3px}
  .chip{display:inline-block;padding:4px 8px;border:1px solid rgba(255,255,255,.15);border-radius:999px;font-size:12px}
  .spacer{flex:1}
  .btn{appearance:none;border:0;border-radius:12px;padding:10px 14px;font-weight:700;cursor:pointer;color:white;background:linear-gradient(135deg,#7c5cff,#1d9bf0)}
  .btn.small{padding:7px 10px;border-radius:10px}
  .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.18);color:var(--ink)}
  .tabs{max-width:1200px;margin:12px auto 0;padding:0 16px}
  .tabbar{display:flex;gap:8px;flex-wrap:wrap}
  .tabbar button{appearance:none;background:#111422;border:1px solid rgba(255,255,255,.10);color:var(--ink);padding:10px 12px;border-radius:10px;cursor:pointer}
  .tabbar button.active{background:linear-gradient(135deg,#7c5cff,#1d9bf0);border-color:transparent}
  .tabpanes{margin-top:12px}
  .wrap{max-width:1200px;margin:0 auto;padding:0 16px 120px}
  .card{background:#111422;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:18px}
  label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
  input,select{width:100%;padding:10px 12px;border:1px solid rgba(255,255,255,.15);border-radius:10px;background:#0e1220;color:var(--ink);outline:none}
  input[readonly]{opacity:.85}
  input:focus,select:focus{border-color:var(--brand);box-shadow:0 0 0 3px var(--ring)}
  .row{display:grid;grid-template-columns:1fr;gap:12px}
  @media (min-width:960px){ .row-2{grid-template-columns:repeat(2,1fr)} .row-3{grid-template-columns:repeat(3,1fr)} .row-4{grid-template-columns:repeat(4,1fr)} }
  .help{font-size:12px;color:var(--muted)}
  .cta{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)} .hidden{display:none}
  .kpi{display:flex;gap:10px;flex-wrap:wrap;margin:10px 0}
  .kpi .box{border:1px solid rgba(255,255,255,.14);border-radius:12px;padding:10px 12px}
  .kpi .label{font-size:11px;color:var(--muted)} .kpi .value{font-weight:700}
  .table{width:100%;border-collapse:collapse;margin-top:10px}
  .table th,.table td{padding:8px 10px;border-bottom:1px solid rgba(255,255,255,.08);font-size:13px;text-align:left}
  .table th{color:#b8c0cc;font-weight:600}
  .right{text-align:right}
  .tag{display:inline-block;padding:4px 8px;border:1px solid rgba(255,255,255,.15);border-radius:999px;font-size:12px}
  .best{background:rgba(52,211,153,.08);border-color:rgba(52,211,153,.35)}
  @keyframes spin { 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} }
  .spinner {border:4px solid rgba(255,255,255,.2);border-top:4px solid #7c5cff;border-radius:50%;width:32px;height:32px;animation:spin 1s linear infinite;display:inline-block;vertical-align:middle}
  .pill {display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.15);font-size:12px;margin-left:6px}
  .toast {position:fixed;right:16px;bottom:16px;background:#161a2b;border:1px solid rgba(255,255,255,.12);padding:10px 12px;border-radius:10px;opacity:0;transform:translateY(8px);transition:.25s;z-index:30}
  .toast.show{opacity:1;transform:translateY(0)}
</style>
</head>
<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div class="logo"><span>CK</span></div>
      <div class="brand">Crypto Kings</div>
      <span class="chip">v8.5.0</span>
      <div class="spacer"></div>
      <button id="btnConnect" class="btn">Connect Wallet</button>
    </div>
  </div>

  <div class="tabs">
    <div class="tabbar" id="tabbar"></div>
    <div class="tabpanes" id="tabpanes"></div>
  </div>

  <div id="toast" class="toast" aria-live="polite"></div>

<script>
(() => {
  /* ========================
     TUNABLE LIMITS (local)
     ======================== */
  const MAX_ADDRESSES_PER_SCAN = 80;    // how many token addresses to sample per network
  const CONCURRENCY            = 6;     // parallel Dexscreener requests
  const MIN_LIQ_USD            = 20000; // ignore low-liquidity pools
  const MIN_VOL24H_USD         = 5000;  // ignore low-volume pools
  const LOAN_CAP_USD           = 10000; // max loan cap
  const DEFAULT_PLATFORM       = "Aave v3";
  const PLATFORM_FEE           = 0.0009;  // 0.09% default

  /* ========================
     STATIC REFS & HELPERS
     ======================== */
  const NETWORKS = ["ethereum","arbitrum","polygon","bsc","avalanche","solana"];
  const NET_LABEL = { ethereum:"Ethereum", arbitrum:"Arbitrum", polygon:"Polygon", bsc:"BSC", avalanche:"Avalanche", solana:"Solana" };
  const EVM = new Set(["ethereum","arbitrum","polygon","bsc","avalanche"]);
  const DS_BASE = "https://api.dexscreener.com";
  const fmtUSD = v => isFinite(v) ? `$${Number(v).toLocaleString(undefined,{maximumFractionDigits:6})}` : "—";
  const toast = (msg)=>{ const t=document.getElementById("toast"); t.textContent=msg; t.classList.add("show"); setTimeout(()=>t.classList.remove("show"), 2200); };
  const norm = s => (s||"").toLowerCase().replace(/[^a-z0-9]/g,"");

  const TOKENLISTS = {
    ethereum: [
      "https://tokens.uniswap.org",
      "https://unpkg.com/@uniswap/default-token-list@latest/build/uniswap-default.tokenlist.json"
    ],
    arbitrum: [
      "https://unpkg.com/@uniswap/default-token-list@latest/build/uniswap-default.tokenlist.json"
    ],
    polygon: [
      "https://unpkg.com/quickswap-default.token-list@latest/build/quickswap-default.tokenlist.json",
      "https://unpkg.com/@uniswap/default-token-list@latest/build/uniswap-default.tokenlist.json"
    ],
    bsc: [
      "https://tokens.pancakeswap.finance/pancakeswap-extended.json"
    ],
    avalanche: [
      "https://raw.githubusercontent.com/traderjoe-xyz/joe-tokenlists/main/joe.tokenlist.json"
    ],
    solana: [
      // for SOL we'll keep it simple; DS coverage varies
    ]
  };

  const RPC={ ethereum:["https://rpc.ankr.com/eth","https://eth-mainnet.public.blastapi.io","https://cloudflare-eth.com"], arbitrum:["https://rpc.ankr.com/arbitrum","https://arbitrum.llamarpc.com","https://arb1.arbitrum.io/rpc"], polygon:["https://rpc.ankr.com/polygon","https://polygon-bor-rpc.publicnode.com","https://polygon-rpc.com"], bsc:["https://rpc.ankr.com/bsc","https://bsc.publicnode.com","https://bsc-dataseed1.binance.org"], avalanche:["https://rpc.ankr.com/avalanche","https://ava-mainnet.public.blastapi.io","https://api.avax.network/ext/bc/C/rpc"] };
  const GAS_NATIVE = { ethereum:"ETH", arbitrum:"ETH", polygon:"MATIC", bsc:"BNB", avalanche:"AVAX" };
  const CG_IDS={"ETH":"ethereum","WETH":"ethereum","MATIC":"matic-network","BNB":"binancecoin","AVAX":"avalanche-2"};

  async function getJSON(url, ttl=60){
    const r = await fetch(url, { cf:{ cacheEverything:true, cacheTtl:ttl } }).catch(()=>null);
    if(!r || !r.ok) throw new Error(`GET ${url} -> ${r?.status||"ERR"}`);
    return r.json();
  }
  async function loadTokenAddresses(network){
    const lists = TOKENLISTS[network] || [];
    const addrs = new Set();
    for(const url of lists){
      try{
        const tl = await getJSON(url, 300);
        const tokens = tl?.tokens || [];
        for(const t of tokens){
          if(!t.address) continue;
          const ok =
            (network === "ethereum" && (t.chainId == 1)) ||
            (network === "arbitrum" && (t.chainId == 42161)) ||
            (network === "polygon" && (t.chainId == 137)) ||
            (network === "bsc" && (t.chainId == 56)) ||
            (network === "avalanche" && (t.chainId == 43114));
          if(ok) addrs.add(t.address);
        }
      }catch(_){}
    }
    const arr = Array.from(addrs);
    return arr.slice(0, Math.min(arr.length, MAX_ADDRESSES_PER_SCAN));
  }

  async function dsByToken(addr){
    const url = `${DS_BASE}/latest/dex/tokens/${addr}`;
    const r = await fetch(url, { cache:"no-store" }).catch(()=>null);
    if(!r || !r.ok) return null;
    return r.json();
  }

  function consolidatePerDex(pairs){
    const preferred = ["USDC","USDT"];
    const byDex = new Map();
    for(const p of (pairs||[])){
      const dex = (p?.dexId||"").toLowerCase(); if(!dex) continue;
      const liq = p?.liquidity?.usd || 0; if(liq < MIN_LIQ_USD) continue;
      const vol = p?.volume?.h24 || 0; if(vol < MIN_VOL24H_USD) continue;
      const quote = (p?.quoteToken?.symbol||"").toUpperCase();
      const rank = preferred.includes(quote) ? (preferred.indexOf(quote)) : 99;
      const cur = byDex.get(dex);
      if(!cur || rank < cur.rank || (rank === cur.rank && liq > cur.liq)){
        byDex.set(dex, { rec:p, liq, rank });
      }
    }
    return Array.from(byDex.values()).map(x=>x.rec);
  }

  function prettyDexId(p){
    const raw=(p?.dexId||"").toLowerCase();
    const map={ uniswap:"Uniswap V3","uniswap-v3":"Uniswap V3",sushiswap:"SushiSwap",curve:"Curve",balancer:"Balancer",camelot:"Camelot",quickswap:"QuickSwap",pancakeswap:"PancakeSwap","pancakeswap-v3":"PancakeSwap",traderjoe:"Trader Joe",pangolin:"Pangolin",jupiter:"Jupiter",raydium:"Raydium",orca:"Orca" };
    for(const k in map){ if(raw.includes(k)) return map[k]; }
    return raw ? raw.charAt(0).toUpperCase()+raw.slice(1) : "DEX";
  }

  async function mapLimit(items, limit, fn){
    const results = new Array(items.length);
    let i = 0;
    const workers = Array.from({length: Math.min(limit, items.length)}, async ()=>{
      while(i < items.length){
        const idx = i++;
        try{ results[idx] = await fn(items[idx], idx); }catch(_){ results[idx] = null; }
      }
    });
    await Promise.all(workers);
    return results;
  }

  async function gasSuggestGwei(net){
    const eps=RPC[net]; if(!eps) throw new Error("no rpc");
    const feeHist={jsonrpc:"2.0",id:1,method:"eth_feeHistory",params:[5,"latest",[10,50,90]]};
    for(const url of eps){
      try{
        const r=await fetch(url,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(feeHist)});
        if(!r.ok) continue;
        const j=await r.json(); const bh=j?.result; if(!bh?.baseFeePerGas||!bh?.reward) continue;
        const base=parseInt(bh.baseFeePerGas.at(-1)||"0x0",16)/1e9;
        const tip =parseInt((bh.reward.at(-1)?.[1]||"0x0"),16)/1e9;
        return { gasPriceGwei: base+tip, baseGwei:base, tipGwei:tip };
      }catch(_){}
    }
    // fallback
    const gp={jsonrpc:"2.0",id:1,method:"eth_gasPrice",params:[]};
    for(const url of eps){
      try{
        const r=await fetch(url,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(gp)});
        if(!r.ok) continue; const j=await r.json();
        const wei=parseInt(j?.result||"0x0",16); return { gasPriceGwei:wei/1e9, baseGwei:wei/1e9, tipGwei:0 };
      }catch(_){}
    }
    throw new Error("rpc failed");
  }

  async function cgUSD(symbol){
    const id = CG_IDS[symbol]; if(!id) return null;
    try{
      const r = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${id}&vs_currencies=usd`);
      if(!r.ok) return null; const j=await r.json(); return j?.[id]?.usd ?? null;
    }catch(_){ return null; }
  }

  /* ========================
     UI SETUP
     ======================== */
  const tabbar=document.getElementById("tabbar");
  const panes=document.getElementById("tabpanes");

  for(const [i,net] of NETWORKS.entries()){
    const btn=document.createElement("button");
    btn.textContent=NET_LABEL[net];
    if(i===0) btn.classList.add("active");
    tabbar.appendChild(btn);

    const pane=document.createElement("div");
    pane.id=`pane-${net}`; if(i>0) pane.style.display="none";
    pane.innerHTML = `
      <div class="wrap">
        <div class="card">
          <div class="row row-3">
            <div><label>Network</label><input value="${NET_LABEL[net]}" readonly /></div>
            <div><label>Platform</label><input value="${DEFAULT_PLATFORM}" readonly /></div>
            <div><label>Gas Currency</label><input value="${GAS_NATIVE[net]||'-'}" readonly /></div>
          </div>

          <div class="cta" style="margin-top:10px">
            <button class="btn small" data-scan="${net}">Scan All Tokens (sampled)</button>
            <span id="status-${net}" class="help"></span>
          </div>

          <div class="kpi">
            <div class="box"><div class="label">Best Opportunity</div><div class="value" id="kpi-best-${net}">—</div></div>
            <div class="box"><div class="label">Est. Spread</div><div class="value" id="kpi-spread-${net}">—</div></div>
            <div class="box"><div class="label">Net (incl. gas)</div><div class="value" id="kpi-net-${net}">—</div></div>
          </div>

          <div class="row row-3" style="margin-top:8px">
            <div>
              <label>Loan Asset</label>
              <input id="loan-asset-${net}" value="USDC" />
              <div class="help" id="loan-asset-note-${net}">Used to size loan and cap at $10k.</div>
            </div>
            <div>
              <label>Loan Amount (units)</label>
              <input id="loan-amt-${net}" type="number" min="0" step="any" placeholder="e.g., 1000" />
              <div class="help" id="loan-amt-usd-${net}">≈ —</div>
            </div>
            <div>
              <label>Auto Size Loan</label>
              <button class="btn small" id="btn-autosize-${net}" type="button">Auto-Size for Break-Even</button>
              <div class="help">Targets ~breakeven +5% (max $10k).</div>
            </div>
          </div>

          <div class="row row-3" style="margin-top:8px">
            <div>
              <label>Gas (auto)</label>
              <input id="gas-gwei-${net}" placeholder="Auto" readonly />
              <div class="help" id="gas-note-${net}">—</div>
            </div>
            <div>
              <label>Gas Limit (guess)</label>
              <input id="gas-limit-${net}" type="number" min="0" step="1000" placeholder="e.g., 190000" />
              <div class="help">Higher for Curve/Balancer; lower for Uni/Sushi.</div>
            </div>
            <div>
              <label>Est. Gas Cost</label>
              <input id="gas-cost-${net}" placeholder="—" readonly />
              <div class="help" id="gas-cost-usd-${net}">—</div>
            </div>
          </div>

          <div class="help" id="route-${net}" style="margin-top:8px;"></div>

          <table class="table" style="margin-top:10px">
            <thead>
              <tr>
                <th>Token</th>
                <th>Buy (DEX @ $)</th>
                <th>Sell (DEX @ $)</th>
                <th class="right">Spread %</th>
              </tr>
            </thead>
            <tbody id="rows-${net}"></tbody>
          </table>
        </div>
      </div>
    `;
    panes.appendChild(pane);

    btn.addEventListener("click",()=>{
      [...tabbar.children].forEach(b=>b.classList.remove("active"));
      btn.classList.add("active");
      [...panes.children].forEach(p=>p.style.display="none");
      pane.style.display="block";
    });
  }

  /* ========================
     PER-NETWORK STATE
     ======================== */
  const state = {};
  for(const net of NETWORKS){
    state[net] = {
      best: null,         // {base, buyDex, buyPrice, sellDex, sellPrice, spread}
      rows: [],           // table rows
      gasUsd: 0,
      gasNativeUsd: null, // price of native gas token
      gasGwei: null
    };
  }

  /* ========================
     GAS & P/L
     ======================== */
  async function initGas(net){
    if(!EVM.has(net)) return;
    const g = await gasSuggestGwei(net).catch(()=>null);
    const native = GAS_NATIVE[net];
    const nativeUsd = await cgUSD(native).catch(()=>null);

    const gEl = document.getElementById(`gas-gwei-${net}`);
    const note = document.getElementById(`gas-note-${net}`);
    state[net].gasGwei = g?.gasPriceGwei ?? null;
    state[net].gasNativeUsd = nativeUsd ?? null;

    if(g){
      gEl.value = `${g.gasPriceGwei.toFixed(1)} Gwei`;
      note.textContent = `base ${g.baseGwei.toFixed(1)} + tip ${g.tipGwei.toFixed(1)} • ${native} ≈ ${fmtUSD(nativeUsd)}`;
    }else{
      gEl.value = "";
      note.textContent = "auto gas failed (RPC/CORS). Enter gas limit to estimate cost.";
    }
  }

  function calcGasUsd(net){
    if(!EVM.has(net)) return 0;
    const gwei = state[net].gasGwei;
    const gl = parseFloat(document.getElementById(`gas-limit-${net}`).value);
    const nativeUsd = state[net].gasNativeUsd;
    if(!(gwei>0) || !(gl>0) || !(nativeUsd>0)) return 0;
    const eth = (gwei * gl) / 1e9;
    const usd = eth * nativeUsd;
    state[net].gasUsd = usd;
    document.getElementById(`gas-cost-${net}`).value = `${eth.toFixed(6)} ${GAS_NATIVE[net]}`;
    document.getElementById(`gas-cost-usd-${net}`).textContent = `≈ ${fmtUSD(usd)}`;
    return usd;
  }

  async function loanAssetUsd(net){
    const sym = document.getElementById(`loan-asset-${net}`).value.trim().toUpperCase();
    // naive mapping using CG where possible
    const map = {USDC:"usd-coin",USDT:"tether",DAI:"dai",WETH:"ethereum",ETH:"ethereum",WBTC:"wrapped-bitcoin",MATIC:"matic-network",WBNB:"binancecoin",AVAX:"avalanche-2",ARB:"arbitrum",SOL:"solana"};
    const id = map[sym]; if(!id) return null;
    try{
      const r=await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${id}&vs_currencies=usd`);
      const j=await r.json(); return j?.[id]?.usd ?? null;
    }catch(_){ return null; }
  }

  function updateLoanUsdNote(net, price, amount){
    const el = document.getElementById(`loan-amt-usd-${net}`);
    if(!(price>0) || !(amount>=0)) { el.textContent = "≈ —"; return; }
    el.textContent = `≈ ${fmtUSD(price*amount)}`;
  }

  function pickPL(net, principalUsd){
    const best = state[net].best;
    if(!best) return null;
    const fee = PLATFORM_FEE;
    const spread = (best.sellPrice - best.buyPrice)/best.buyPrice;
    const gross = principalUsd * spread;
    const flashFee = principalUsd * fee;
    const gas = state[net].gasUsd || 0;
    return {
      spread, gross, flashFee, gas,
      netNoGas: gross - flashFee,
      net: gross - flashFee - gas
    };
  }

  async function autosizeLoan(net){
    const price = await loanAssetUsd(net);
    const sym = document.getElementById(`loan-asset-${net}`).value.trim().toUpperCase();
    if(!(price>0)) { toast("Loan asset price unavailable"); return; }
    const best = state[net].best;
    if(!best){ toast("No route selected"); return; }
    const fee = PLATFORM_FEE;
    const spread = (best.sellPrice - best.buyPrice)/best.buyPrice;
    const gas = calcGasUsd(net);
    const denom = spread - fee;
    if(!(denom>0)) { toast("Not profitable even before gas"); return; }
    const pMin = gas / denom; // USD to break even
    const target = Math.min(Math.max(pMin*1.05, 100), LOAN_CAP_USD); // +5%, >=$100, <=$10k
    const units = target / price;
    document.getElementById(`loan-amt-${net}`).value = units.toFixed(6);
    updateLoanUsdNote(net, price, units);
    updateKPIs(net);
  }

  async function updateKPIs(net){
    const best = state[net].best;
    const kBest = document.getElementById(`kpi-best-${net}`);
    const kSp   = document.getElementById(`kpi-spread-${net}`);
    const kNet  = document.getElementById(`kpi-net-${net}`);
    if(!best){ kBest.textContent="—"; kSp.textContent="—"; kNet.textContent="—"; return; }

    const amt = parseFloat(document.getElementById(`loan-amt-${net}`).value);
    const px = await loanAssetUsd(net);
    updateLoanUsdNote(net, px||0, isFinite(amt)?amt:0);
    const principalUsd = (isFinite(amt)&&px>0) ? amt*px : 0;

    const r = pickPL(net, principalUsd || 1000); // show sense even without amount
    kBest.textContent = `${best.base} | Buy ${best.buyDex} @ ${fmtUSD(best.buyPrice)} → Sell ${best.sellDex} @ ${fmtUSD(best.sellPrice)}`;
    kSp.textContent   = `${(r.spread*100).toFixed(2)}%`;
    kNet.textContent  = isFinite(principalUsd) && principalUsd>0
      ? `${fmtUSD(r.net)} (fee ${fmtUSD(r.flashFee)}, gas ~ ${fmtUSD(r.gas)})`
      : `set amount to see net (fee ${fmtUSD(r.flashFee)}, gas ~ ${fmtUSD(r.gas)})`;
  }

  /* ========================
     SCAN FLOW
     ======================== */
  async function scanAll(net){
    const status = document.getElementById(`status-${net}`);
    const rowsEl = document.getElementById(`rows-${net}`);
    const route  = document.getElementById(`route-${net}`);
    rowsEl.innerHTML = "";
    route.textContent = "";
    state[net].best = null;

    status.innerHTML = `<span class="spinner"></span> Loading token addresses…`;
    const addrs = await loadTokenAddresses(net).catch(()=>[]);
    if(!addrs.length){ status.textContent = "Could not load token list."; return; }

    let done=0, kept=0;
    status.innerHTML = `<span class="spinner"></span> Scanning ${addrs.length} tokens… (rate-limited safely)`;

    const results = await mapLimit(addrs, CONCURRENCY, async (addr, idx) => {
      const j = await dsByToken(addr);
      done++;
      if(done % 5 === 0) status.innerHTML = `<span class="spinner"></span> Scanned ${done}/${addrs.length}…`;
      if(!j || !j.pairs || !j.pairs.length) return null;
      const onNet = j.pairs.filter(p=>p.chainId===net);
      const perDex = consolidatePerDex(onNet);
      if(!perDex.length) return null;

      // best buy/sell for this token
      let min=Infinity, max=-Infinity, buy=null, sell=null;
      for(const p of perDex){
        const pr = Number(p?.priceUsd);
        if(!isFinite(pr)) continue;
        if(pr < min){ min=pr; buy=p; }
        if(pr > max){ max=pr; sell=p; }
      }
      if(!buy || !sell || !isFinite(min) || !isFinite(max)) return null;
      const spread = (max - min)/min;
      const base = buy?.baseToken?.symbol || sell?.baseToken?.symbol || "";
      kept++;
      return {
        base,
        buyDex: prettyDexId(buy), buyPrice: min, buyUrl: buy?.url || null,
        sellDex: prettyDexId(sell), sellPrice: max, sellUrl: sell?.url || null,
        spread
      };
    });

    const usable = results.filter(Boolean).sort((a,b)=>b.spread - a.spread).slice(0, 100);
    status.textContent = usable.length ? `Found ${usable.length} opportunities` : "No viable routes (liquidity/volume filters).";

    // Render table
    usable.forEach((r,i)=>{
      const tr=document.createElement("tr");
      tr.innerHTML = `
        <td>${r.base}</td>
        <td>${r.buyDex} @ ${fmtUSD(r.buyPrice)}</td>
        <td>${r.sellDex} @ ${fmtUSD(r.sellPrice)}</td>
        <td class="right">${(r.spread*100).toFixed(2)}%</td>
      `;
      tr.style.cursor="pointer";
      tr.addEventListener("click", ()=>{
        state[net].best = r;
        route.innerHTML = `<span class="tag">Selected</span> ${r.base}: Buy ${r.buyDex} @ ${fmtUSD(r.buyPrice)} → Sell ${r.sellDex} @ ${fmtUSD(r.sellPrice)} (spread ${(r.spread*100).toFixed(2)}%)`;
        updateKPIs(net);
      });
      rowsEl.appendChild(tr);
    });

    // Auto-select top row
    if(usable[0]){
      state[net].best = usable[0];
      route.innerHTML = `<span class="tag">Selected</span> ${usable[0].base}: Buy ${usable[0].buyDex} @ ${fmtUSD(usable[0].buyPrice)} → Sell ${usable[0].sellDex} @ ${fmtUSD(usable[0].sellPrice)} (spread ${(usable[0].spread*100).toFixed(2)}%)`;
      updateKPIs(net);
    }
  }

  /* ========================
     WIRE EVENTS
     ======================== */
  document.querySelectorAll("[data-scan]").forEach(btn=>{
    btn.addEventListener("click", ()=> scanAll(btn.dataset.scan));
  });

  for(const net of NETWORKS){
    initGas(net);
    document.getElementById(`gas-limit-${net}`).addEventListener("input", ()=>{ calcGasUsd(net); updateKPIs(net); });
    document.getElementById(`loan-amt-${net}`).addEventListener("input", async ()=>{
      const px = await loanAssetUsd(net); const amt = parseFloat(document.getElementById(`loan-amt-${net}`).value);
      updateLoanUsdNote(net, px||0, isFinite(amt)?amt:0); updateKPIs(net);
    });
    document.getElementById(`btn-autosize-${net}`).addEventListener("click", ()=> autosizeLoan(net));
  }

  // Friendly wallet button
  document.getElementById("btnConnect").addEventListener("click", ()=> toast("Wallet connect coming soon"));
})();
</script>
</body>
</html>I'm 
