<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Crypto Kings • TestBed v9.9.49</title>
<style>
:root{
  --bg:#ffffff; --ink:#111827; --muted:#6b7280; --line:#e5e7eb;
  --card:#f9fafb; --ok:#059669; --warn:#b45309; --bad:#e11d48;
  --g1:#2563eb; --g2:#7c3aed;
}
*{box-sizing:border-box}
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--ink);background:var(--bg)}
header{background:#111;color:#fff;padding:12px 16px;display:flex;justify-content:space-between;align-items:center}
.brand{display:flex;gap:10px;align-items:center}
.logo{width:34px;height:34px;border-radius:8px;background:linear-gradient(135deg,#4f46e5,#22c55e);display:grid;place-items:center;font-weight:800}
.burger{font-size:22px;cursor:pointer;user-select:none}
.container{max-width:1100px;margin:0 auto;padding:16px}
.panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:14px;margin-bottom:16px}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.hint{color:var(--muted);font-size:12px}
input[type=text],input[type=number]{padding:10px 12px;border:1px solid var(--line);border-radius:10px;background:#fff;min-width:160px}
button{border:0;border-radius:10px;padding:10px 16px;font-weight:700;cursor:pointer}
.btn-primary{color:#fff;background:linear-gradient(135deg,var(--g1),var(--g2));box-shadow:0 8px 24px rgba(37,99,235,.2)}
.btn-ghost{background:#eef2f7;color:#111}
.chips{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.pill{padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:#fff;font-size:12px;color:#111}
.toolbar{display:flex;gap:10px;align-items:center;flex-wrap:wrap;padding-bottom:10px;border-bottom:1px solid var(--line);margin-bottom:10px}
table{width:100%;border-collapse:collapse;table-layout:fixed}
thead th{background:#f3f4f6;border-bottom:1px solid var(--line);padding:10px 12px;color:#374151;font-weight:700}
tbody td{border-bottom:1px solid var(--line);padding:10px 12px;vertical-align:top}
.right{text-align:right}
.mono{font-variant-numeric:tabular-nums}
tr.profit{background:#ecfdf5}
tr.loss{background:#fff1f2}
.ok{color:var(--ok)} .bad{color:var(--bad)} .warn{color:var(--warn)}
.tag{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);border-radius:999px;padding:2px 8px;font-size:12px;background:#fff}
.logs{background:#0b1220;color:#a7f3d0;border:1px solid #0f1b34;border-radius:12px;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap;max-height:240px;overflow:auto}
footer{background:#111;color:#ddd;padding:24px}
.foot{max-width:1100px;margin:0 auto;display:grid;gap:18px;grid-template-columns:repeat(4,1fr)}
footer h4{color:#fff;margin:0 0 10px;font-size:16px}
footer ul{list-style:none;margin:0;padding:0}
footer li{margin:6px 0}
@media(max-width:800px){ .foot{grid-template-columns:1fr 1fr} }
@media(max-width:560px){ .foot{grid-template-columns:1fr} }
@media(max-width:720px){
  thead{display:none}
  tbody tr{display:grid;grid-template-columns:1fr 1fr;grid-row-gap:6px;padding:10px 12px}
  tbody td{border:0;padding:0}
  td.sel{grid-column:1/-1;order:-3;margin-bottom:4px}
  td.tok{grid-column:1/-1;font-weight:700;order:-2}
  td.flags{grid-column:1/-1;order:-1;margin-top:6px}
  .cell{display:flex;justify-content:space-between;gap:8px}
  .lbl{color:#6b7280;font-size:12px;margin-right:8px}
  .val{text-align:right}
  .toolbar .btn-primary,.toolbar .btn-ghost{width:100%}
}
</style>
</head>
<body>
<header>
  <div class="brand">
    <div class="logo">CK</div>
    <div>
      <div style="font-weight:800;line-height:1">Crypto Kings</div>
      <div class="hint">TestBed v9.9.49 • Arbitrum (Sushi ↔ Camelot ↔ Ramses • router-verified • adaptive quotes)</div>
    </div>
  </div>
  <div class="burger" title="Menu">&#9776;</div>
</header>

<div class="container">
  <!-- Contract Settings -->
  <div class="panel">
    <div style="font-weight:700;margin-bottom:8px">Contract Settings (required for on-chain execute)</div>
    <div class="row">
      <input id="execContract" type="text" placeholder="Executor contract address (0x…)" style="min-width:340px"/>
      <input id="feeWallet" type="text" placeholder="Your fee wallet (0x…)" style="min-width:300px"/>
      <input id="payoutWalletB" type="text" placeholder="2nd profit wallet (optional)" style="min-width:300px"/>
      <input id="splitPctB" type="number" min="0" max="100" step="1" value="0" title="% of profit to wallet B"/>
    </div>
    <div class="row" style="margin-top:8px">
      <button id="connectBtn" class="btn-ghost">Connect</button>
      <input id="wethAmt" type="number" min="0.00001" step="0.00001" value="0.003" title="WETH loan size used for quotes & smoke test"/>
      <button id="fundBtn" class="btn-ghost" title="Wrap tiny ETH→WETH and send premium to the contract">Fund Premium</button>
      <button id="flashBtn" class="btn-primary">Start Flash Loan (WETH)</button>
    </div>
    <div class="hint" id="execHint">Paste your CKFlashExecutor (Arbitrum 42161). WETH amount above feeds router quotes and smoke-test loan.</div>
  </div>

  <!-- Scan Panel -->
  <div class="panel">
    <div class="row">
      <label class="hint">Loan Amount (USDC):</label>
      <input id="loan" type="number" min="100" step="100" value="10000"/>
      <button id="scanBtn" class="btn-primary">Scan</button>
      <button id="stopBtn" class="btn-ghost">Stop</button>
    </div>
    <div class="chips">
      <span class="pill" id="rpcPill">RPC: Alchemy</span>
      <span class="pill" id="tokensPill">Tokens: —</span>
      <span class="pill" id="gasPill">Gas: —</span>
      <span class="pill" id="ethPill">ETH: —</span>
      <span class="pill" id="progPill">Idle.</span>
    </div>
  </div>

  <!-- Results Panel -->
  <div class="panel">
    <div class="toolbar">
      <button id="selectProfitable" class="btn-ghost">Select all profitable</button>
      <button id="clearSel" class="btn-ghost">Clear</button>
      <span id="selTotal" class="pill">++$0</span>
      <button id="execSelected" class="btn-primary" style="margin-left:auto">Execute Selected (one route)</button>
    </div>
    <table id="results">
      <thead>
        <tr>
          <th style="width:42px">Select</th>
          <th>Token</th>
          <th>Buy (DEX @ $)</th>
          <th>Sell (DEX @ $)</th>
          <th class="right">Spread %</th>
          <th class="right">USDC Back</th>
          <th class="right">Net P/L</th>
          <th>Executable?</th>
        </tr>
      </thead>
      <tbody id="tbody"></tbody>
    </table>
  </div>

  <!-- Logs Panel -->
  <div class="panel">
    <div class="row" style="justify-content:space-between">
      <div style="font-weight:700">Details / Logs</div>
      <span class="hint">Live gas (Alchemy) • ETH/USD (CoinGecko) • Dexscreener pools • Router-verified quotes</span>
    </div>
    <div id="log" class="logs">Ready.</div>
  </div>
</div>

<footer>
  <div class="foot">
    <div>
      <h4>Crypto Kings</h4>
      <ul><li>Arbitrage Scanner</li><li>DeFi Tools</li><li>Risk Analysis</li></ul>
    </div>
    <div>
      <h4>Company</h4>
      <ul><li>Who we are</li><li>What we do</li><li>Connect with us</li></ul>
    </div>
    <div>
      <h4>Resources</h4>
      <ul><li>Docs</li><li>Blog</li><li>Support</li></ul>
    </div>
    <div>
      <h4>Legal</h4>
      <ul><li>Privacy</li><li>Terms</li><li>Disclaimer</li></ul>
    </div>
  </div>
</footer>

<!-- ========= CONTRACT + SCANNER ========= -->
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<script>
/* ========= CONFIG ========= */
const DEFAULT_EXECUTOR_ADDR = "0x43327acEAd76dCD48A09cc93A509a2FE7b1f0f5c";
const ARBITRUM_CHAIN_ID_DEC = 42161;
const ARBITRUM_CHAIN_ID_HEX = "0xa4b1";
const WETH  = "0x82aF49447D8a07e3BD95BD0d56f35241523fBab1";
const USDCe = "0xff970a61a04b1ca14834a43f5de4533ebddb5cc8";

const ROUTER_BY_DEX = {
  "SUSHISWAP": "0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506",
  "CAMELOT":   "0xC873FECbD354f5A56E00E710B90EF4201Db2448d",
  "RAMSES":    "0xAAEAfD6e975fF4811fB8F8bBF27106e2164F3E3E"
};
const DEX_CANON = dex => {
  dex = String(dex||"").toLowerCase();
  if (dex.includes("sushi")) return "SUSHISWAP";
  if (dex.includes("camelot")) return "CAMELOT";
  if (dex.includes("ramses")) return "RAMSES";
  return null;
};

const ALCHEMY_URL   = "https://arb-mainnet.g.alchemy.com/v2/h4YaGX9cc_WywAx5cvsez";
const READ_PROVIDER = new ethers.providers.JsonRpcProvider(ALCHEMY_URL);

const DEX_FEE   = 0.003;
const SLIP_FEE  = 0.002;
const FLASH_FEE = 0.0005;
const SPREAD_CAP = 75;
const GAS_LIMIT = 380000;

/* Tokens (kept & expanded lightly) */
const TOKENS = [
  "USDC","USDT","DAI","ARB","WBTC","LINK","GMX","AAVE","RDNT","PENDLE","FRAX","CRV","BAL","UNI","wstETH","SNX","COMP","YFI","GRT",
  "STG","LQTY","RPL","MKR","ENS","CVX","FXS","SUSHI","LUSD","MAGIC","BADGER","OP","GNS","DPX","RDPX","GRAIL","ALCX","ANGLE","PERP",
  "1INCH","VELO","AURA","BOND","LYRA","JONES","WOO","LDO","ZRX","ZRO","AEVO"
];

/* ========= HELPERS ========= */
const $=s=>document.querySelector(s);
const tbody=$("#tbody"), logEl=$("#log");
function log(m){ logEl.textContent += (m.endsWith("\n")?m:m+"\n"); logEl.scrollTop=logEl.scrollHeight; }
function usd(n){ return Number(n).toLocaleString(undefined,{style:'currency',currency:'USD',maximumFractionDigits:2}); }
function getExecAddr(){ const v=($("#execContract").value||"").trim(); return /^0x[a-fA-F0-9]{40}$/.test(v)?v:DEFAULT_EXECUTOR_ADDR; }

/* ========= ETH & GAS ========= */
let ETH_USD=null, GAS_GWEI=null;
async function fetchEthUsd(){
  try{
    const r=await fetch("https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd",{cache:"no-store"});
    const j=await r.json(); ETH_USD=Number(j?.ethereum?.usd)||null;
    $("#ethPill").textContent="ETH: "+(ETH_USD?usd(ETH_USD):"—");
  }catch(_){ $("#ethPill").textContent="ETH: (fail)"; }
}
async function fetchGasGwei(){
  try{
    const body={jsonrpc:"2.0",id:1,method:"eth_gasPrice",params:[]};
    const r=await fetch(ALCHEMY_URL,{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify(body)});
    const j=await r.json(); const wei=parseInt(j?.result||"0x0",16);
    GAS_GWEI=wei/1e9; $("#gasPill").textContent="Gas: "+GAS_GWEI.toFixed(2)+" gwei";
  }catch(_){ $("#gasPill").textContent="Gas: (fail)"; GAS_GWEI=0.05; }
}

/* ========= Dexscreener ========= */
const MIN_LIQ_USD=300; // low to surface rows
async function fetchPairsForSymbol(sym){
  try{
    const url="https://api.dexscreener.com/latest/dex/search?q="+encodeURIComponent(sym);
    const r=await fetch(url,{cache:"no-store"}); if(!r.ok) return [];
    const j=await r.json();
    const raw=(j?.pairs||[]).filter(p=>p?.chainId==="arbitrum");
    const out=[];
    for(const p of raw){
      const canon=DEX_CANON(p?.dexId);
      if(!canon || !ROUTER_BY_DEX[canon]) continue;
      const liq=Number(p?.liquidity?.usd||0); if(liq<MIN_LIQ_USD) continue;

      const baseA=(p?.baseToken?.address||"").toLowerCase();
      const baseS=(p?.baseToken?.symbol||"").toUpperCase();
      const quoteA=(p?.quoteToken?.address||"").toLowerCase();
      const quoteS=(p?.quoteToken?.symbol||"").toUpperCase();

      if(baseS===sym.toUpperCase()) out.push({dexId:canon, tokenAddr:baseA, tokenSymbol:baseS, priceUsd:Number(p?.priceUsd||0), liq});
      if(quoteS===sym.toUpperCase()) out.push({dexId:canon, tokenAddr:quoteA, tokenSymbol:quoteS, priceUsd:Number(p?.priceUsd||0), liq});
    }
    // dedupe by (dex, token)
    const best=new Map();
    for(const t of out){
      const k=t.dexId+"::"+t.tokenAddr;
      const cur=best.get(k);
      if(!cur || t.liq>(cur.liq||0)) best.set(k,t);
    }
    return Array.from(best.values());
  }catch(e){ log("pairs "+sym+": "+(e?.message||e)); return []; }
}

/* ========= V2 quoting (with fallbacks & adaptive sizes) ========= */
const V2_ABI=["function getAmountsOut(uint amountIn, address[] calldata path) view returns (uint[] memory amounts)"];
function router(addr){ return new ethers.Contract(addr, V2_ABI, READ_PROVIDER); }
async function amountsOut(r, amt, path){ try{ const res=await r.getAmountsOut(amt, path); return res[res.length-1]; }catch(_){ return null; } }

async function tryPaths(buyR, sellR, amountIn, token){
  if(token.toLowerCase()===WETH.toLowerCase()) return null; // skip WETH self
  // 1) direct
  let mid=await amountsOut(buyR, amountIn, [WETH, token]);
  if(mid){ const back=await amountsOut(sellR, mid, [token, WETH]); if(back) return {midOut:mid, backWei:back, via:"direct"}; }
  // 2) via USDCe
  mid=await amountsOut(buyR, amountIn, [WETH, USDCe, token]);
  if(mid){ const back=await amountsOut(sellR, mid, [token, USDCe, WETH]); if(back) return {midOut:mid, backWei:back, via:"usdc"}; }
  return null;
}

async function quoteRoundTripAdaptive(buyDex, sellDex, token, humanWeth){
  const buyAddr=ROUTER_BY_DEX[buyDex], sellAddr=ROUTER_BY_DEX[sellDex];
  if(!buyAddr || !sellAddr) return {ok:false, reason:"router-missing"};
  const rBuy=router(buyAddr), rSell=router(sellAddr);

  // sizes to try: UI value then tiny fallbacks
  const sizes=[humanWeth, "0.001", "0.0005", "0.0001"].map(s=>ethers.utils.parseUnits(s,18));
  for(const amt of sizes){
    const rt=await tryPaths(rBuy, rSell, amt, token);
    if(rt) return {ok:true, ...rt, amountIn:amt};
  }
  return {ok:false, reason:"all-sizes-failed"};
}

/* ========= Profit calc & render ========= */
let collect=[];
async function routeForToken(pairs, humanWeth){
  let best=null;
  const dexes=["SUSHISWAP","CAMELOT","RAMSES"];
  for(const t of pairs){
    for(const buyDex of dexes){
      for(const sellDex of dexes){
        if(buyDex===sellDex) continue;
        const hasBuy = pairs.some(p=>p.dexId===buyDex && p.tokenAddr===t.tokenAddr);
        const hasSell= pairs.some(p=>p.dexId===sellDex&& p.tokenAddr===t.tokenAddr);
        if(!hasBuy || !hasSell) continue;

        const q=await quoteRoundTripAdaptive(buyDex, sellDex, t.tokenAddr, humanWeth);
        if(!q.ok){
          collect.push({token:t.tokenSymbol, tokenAddr:t.tokenAddr, buyDex, sellDex,
            buyPrice:NaN, sellPrice:NaN, spreadPct:NaN, usdcBack:NaN,
            netPL:NaN, execFlag:"⚠️ Quote failed (size/pool)"});
          continue;
        }

        const {amountIn, backWei}=q;
        const totalPct=(DEX_FEE+SLIP_FEE)*2 + FLASH_FEE;
        const feeWei = amountIn.mul(Math.floor(totalPct*1e6)).div(1e6);
        const gasPriceWei=ethers.utils.parseUnits(String(GAS_GWEI||0.05),"gwei");
        const gasWei=gasPriceWei.mul(GAS_LIMIT);
        const netPLWei=backWei.sub(feeWei).sub(gasWei).sub(amountIn);
        const netPLUsd = ETH_USD ? Number(ethers.utils.formatUnits(netPLWei,18))*ETH_USD : 0;

        const row={
          token:t.tokenSymbol, tokenAddr:t.tokenAddr, buyDex, sellDex,
          buyPrice:Number(t.priceUsd)||NaN, sellPrice:Number(t.priceUsd)||NaN,
          spreadPct:NaN, usdcBack:NaN,
          netPL:netPLUsd, netPLWei, execFlag:"✅ Router-verified"
        };
        collect.push(row);
        if(!best || netPLWei.gt(best.netPLWei)) best=row;
      }
    }
  }
  return best;
}

function renderRows(rows){
  rows.sort((a,b)=>{
    const ap=isFinite(a.netPL)&&a.netPL>0, bp=isFinite(b.netPL)&&b.netPL>0;
    if(ap!==bp) return bp-ap;
    return (isFinite(b.netPL)?b.netPL:-1e99)-(isFinite(a.netPL)?a.netPL:-1e99);
  });
  tbody.innerHTML="";
  for(const r of rows){
    const tr=document.createElement("tr");
    const good=isFinite(r.netPL)&&r.netPL>0;
    tr.className=good?"profit":"loss";
    tr.dataset.netpl=isFinite(r.netPL)?r.netPL:"";
    tr.dataset.token=r.token;
    tr.dataset.tokenAddr=r.tokenAddr||"";
    tr.dataset.buyDex=r.buyDex;
    tr.dataset.sellDex=r.sellDex;

    tr.innerHTML=`
      <td class="sel"><input type="checkbox" class="pick" ${good?"checked":""}></td>
      <td class="tok">${r.token}</td>
      <td><div class="cell"><span class="lbl">Buy</span><span class="val">${r.buyDex} @ ${isFinite(r.buyPrice)?Number(r.buyPrice).toLocaleString(undefined,{maximumFractionDigits:6}):"—"}</span></div></td>
      <td><div class="cell"><span class="lbl">Sell</span><span class="val">${r.sellDex} @ ${isFinite(r.sellPrice)?Number(r.sellPrice).toLocaleString(undefined,{maximumFractionDigits:6}):"—"}</span></div></td>
      <td class="right mono">${isFinite(r.spreadPct)?r.spreadPct.toFixed(2):"—"}%</td>
      <td class="right mono">${isFinite(r.usdcBack)?usd(r.usdcBack):"—"}</td>
      <td class="right mono ${good?'ok':(isFinite(r.netPL)?'bad':'warn')}">${isFinite(r.netPL)?((r.netPL>=0?'+':'-')+usd(Math.abs(r.netPL)).replace('$','')):'n/a'}</td>
      <td class="flags"><span class="tag ${r.execFlag.includes('verified')?'ok':'warn'}">${r.execFlag}</span></td>
    `;
    tbody.appendChild(tr);
  }
  updateSelectedTotal();
}
function updateSelectedTotal(){
  let sum=0;
  tbody.querySelectorAll(".pick:checked").forEach(cb=>{
    const tr=cb.closest("tr"); sum += Number(tr.dataset.netpl||0);
  });
  $("#selTotal").textContent=(sum>=0?'++$':'−$')+Math.abs(sum).toLocaleString(undefined,{maximumFractionDigits:2});
}

/* ========= Scan flow ========= */
let stopFlag=false, scanning=false;
async function runScan(){
  if(scanning) return; scanning=true; stopFlag=false; collect=[];
  $("#progPill").textContent="Preparing (gas, ETH)…";
  tbody.innerHTML=""; updateSelectedTotal(); logEl.textContent="Ready.\n";

  const loan=Number($("#loan").value||10000);
  await Promise.all([fetchEthUsd(), fetchGasGwei()]);
  $("#progPill").textContent="Scanning pools…";
  log(`[${new Date().toLocaleTimeString()}] CLICK Scan; tokens=${TOKENS.length}; loan=${loan.toLocaleString()}`);

  const humanAmt=String($("#wethAmt").value||"0.003");

  const found=[];
  for(let i=0;i<TOKENS.length;i++){
    if(stopFlag) break;
    const sym=TOKENS[i];
    $("#progPill").textContent=`Scanning ${i+1}/${TOKENS.length} — ${sym}`;
    log(`${sym}: fetching Dexscreener…`);
    const pairs=await fetchPairsForSymbol(sym);
    if(!pairs.length){ log(`${sym}: no Sushi/Camelot/Ramses pools kept`); continue; }

    const best=await routeForToken(pairs, humanAmt);
    if(best){
      found.push(best);
      log(`${sym}: best ${best.buyDex}→${best.sellDex} ${isFinite(best.netPL)?usd(best.netPL):'n/a'} @ ${humanAmt} WETH`);
    }else{
      log(`${sym}: no router-verified route at tested sizes`);
    }
  }
  renderRows(collect.length?collect:found);
  const rows=(collect.length?collect:found);
  $("#progPill").textContent=`Done. Rows=${rows.length} | Green=${rows.filter(r=>isFinite(r.netPL)&&r.netPL>0).length}.`;
  scanning=false;
}

/* ========= CKFE wires ========= */
const CKFE_ABI=[{"inputs":[{"internalType":"address","name":"asset","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"components":[{"internalType":"address","name":"buyRouter","type":"address"},{"internalType":"address","name":"sellRouter","type":"address"},{"internalType":"address","name":"targetToken","type":"address"},{"internalType":"uint256","name":"minBuyOut","type":"uint256"},{"internalType":"uint256","name":"minSellOut","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct CKFE.Route","name":"r","type":"tuple"}],"name":"startFlashTrade","outputs":[],"stateMutability":"nonpayable","type":"function"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"asset","type":"address"},{"indexed":false,"internalType":"uint256","name":"repaid","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"profit","type":"uint256"}],"name":"FlashCompleted","type":"event"}];
const V2_QUOTE_ABI=["function getAmountsOut(uint amountIn, address[] calldata path) view returns (uint[] memory amounts)"];
let __provider,__signer,__account,__ckfe;

async function connectWallet(){
  if(!window.ethereum) throw new Error("MetaMask not found");
  __provider=new ethers.providers.Web3Provider(window.ethereum,"any");
  await __provider.send("eth_requestAccounts",[]);
  const net=await __provider.getNetwork();
  if(Number(net.chainId)!==ARBITRUM_CHAIN_ID_DEC){
    try{ await __provider.send("wallet_switchEthereumChain",[{chainId:ARBITRUM_CHAIN_ID_HEX}]); }
    catch(e){ throw new Error("Please switch MetaMask to Arbitrum One"); }
  }
  __signer=__provider.getSigner();
  __account=await __signer.getAddress();
  const feeBox=$("#feeWallet"); if(feeBox) feeBox.value=__account;
  const addr=getExecAddr();
  __ckfe=new ethers.Contract(addr, CKFE_ABI, __signer);
  const box=$("#execContract"); if(box) box.value=addr;
  $("#progPill").textContent="Connected.";
  log("✅ Wallet connected: "+__account+" | CKFE: "+addr);
  return __ckfe;
}

async function fundPremium(){
  const human=String($("#wethAmt").value||"0.01");
  const amount=ethers.utils.parseUnits(human,18);
  const premium=amount.mul(5).div(10000);
  const buffer=premium.mul(2).div(100);
  const wrapVal=premium.add(buffer);
  const c=__ckfe||await connectWallet();
  const execAddr=c.address;
  const weth=new ethers.Contract(WETH,["function deposit() payable","function transfer(address to,uint256 value) returns (bool)"],__signer);
  log(`Wrapping ~${ethers.utils.formatUnits(wrapVal,18)} ETH → WETH`);
  const depTx=await weth.deposit({value:wrapVal}); await depTx.wait();
  log(`Sending premium ${ethers.utils.formatUnits(premium,18)} WETH → ${execAddr}`);
  const sendTx=await weth.transfer(execAddr,premium); await sendTx.wait();
  log(`✅ Premium funded. Tx: ${sendTx.hash}`); alert("Premium funded.\n"+sendTx.hash);
}

async function startFlashLoan(){
  const human=String($("#wethAmt").value||"0.003");
  const amount=ethers.utils.parseUnits(human,18);
  const c=__ckfe||await connectWallet();
  const r=new ethers.Contract(ROUTER_BY_DEX.SUSHISWAP, V2_QUOTE_ABI, READ_PROVIDER);
  let minBuyOut=ethers.constants.One, minSellOut=ethers.constants.One;
  try{
    const b=await r.getAmountsOut(amount,[WETH,USDCe]); const u=b[b.length-1];
    const s=await r.getAmountsOut(u,[USDCe,WETH]); const w=s[s.length-1];
    minBuyOut=u.mul(98).div(100); minSellOut=w.mul(98).div(100);
  }catch(_){}
  const route={buyRouter:ROUTER_BY_DEX.SUSHISWAP, sellRouter:ROUTER_BY_DEX.SUSHISWAP, targetToken:USDCe, minBuyOut, minSellOut, deadline:0};
  try{ await c.callStatic.startFlashTrade(WETH, amount, route); log("staticCall: would succeed ✅"); }
  catch(err){ log("staticCall revert ❌ "+(err?.reason||err?.message||"")); }
  const tx=await c.startFlashTrade(WETH, amount, route, {gasLimit:3_500_000});
  log("tx: "+tx.hash); const rcpt=await tx.wait(); log(`✅ Executed | Block ${rcpt.blockNumber} | logs: ${rcpt.logs.length}`);
}

/* ========= Execute 1 selected ========= */
async function executeSelected(){
  const picks=Array.from(document.querySelectorAll("#tbody .pick:checked"));
  if(picks.length!==1){ alert("Please select exactly 1 row."); return; }
  const row=picks[0].closest("tr");
  const tokenAddr=(row.dataset.tokenAddr||"").toLowerCase();
  if(!/^0x[a-f0-9]{40}$/.test(tokenAddr)){ alert("Missing token address on the selected row."); return; }
  const buyDex=row.dataset.buyDex, sellDex=row.dataset.sellDex;
  const buyRouter=ROUTER_BY_DEX[buyDex], sellRouter=ROUTER_BY_DEX[sellDex];
  if(!buyRouter||!sellRouter){ alert("Missing router for selected DEX."); return; }
  const human=String($("#wethAmt").value||"0.003");
  const amount=ethers.utils.parseUnits(human,18);
  const c=__ckfe||await connectWallet();

  // conservative minOuts via USDC path
  const rBuy=new ethers.Contract(buyRouter, V2_QUOTE_ABI, READ_PROVIDER);
  const rSell=new ethers.Contract(sellRouter,V2_QUOTE_ABI, READ_PROVIDER);
  let minBuyOut=ethers.constants.One, minSellOut=ethers.constants.One;
  try{
    const mid=await rBuy.getAmountsOut(amount,[WETH,USDCe,tokenAddr]); const m=mid[mid.length-1];
    const back=await rSell.getAmountsOut(m,[tokenAddr,USDCe,WETH]); const b=back[back.length-1];
    minBuyOut=m.mul(98).div(100); minSellOut=b.mul(98).div(100);
  }catch(_){ log("Quote failed; using minOut=1."); }

  const route={buyRouter, sellRouter, targetToken:tokenAddr, minBuyOut, minSellOut, deadline:0};

  try{ await c.callStatic.startFlashTrade(WETH, amount, route); log("staticCall: would succeed ✅"); }
  catch(err){ log("staticCall revert ❌ "+(err?.reason||err?.message||"")); }

  const tx=await c.startFlashTrade(WETH, amount, route, {gasLimit:3_500_000});
  log("⛓️ tx: "+tx.hash); const rcpt=await tx.wait(); log(`✅ Mined block ${rcpt.blockNumber} | logs: ${rcpt.logs.length}`);
}

/* ========= Wire UI ========= */
function wireUI(){
  $("#scanBtn").addEventListener("click", runScan);
  $("#stopBtn").addEventListener("click", ()=>{ stopFlag=true; $("#progPill").textContent="Stopped."; });
  tbody.addEventListener("change", e=>{ if(e.target.classList.contains("pick")) updateSelectedTotal(); });
  $("#selectProfitable").addEventListener("click", ()=>{
    tbody.querySelectorAll("tr").forEach(tr=>{ const cb=tr.querySelector(".pick"); if(cb) cb.checked=(Number(tr.dataset.netpl||-1e99)>0); });
    updateSelectedTotal();
  });
  $("#clearSel").addEventListener("click", ()=>{ tbody.querySelectorAll(".pick").forEach(cb=>cb.checked=false); updateSelectedTotal(); });
  $("#execSelected").addEventListener("click", executeSelected);
  $("#connectBtn").addEventListener("click", async ()=>{ try{ await connectWallet(); }catch(e){ alert(e?.message||e); } });
  $("#fundBtn").addEventListener("click", async ()=>{ try{ await connectWallet(); await fundPremium(); }catch(e){ console.error(e); alert(e?.data?.message||e?.message||e); } });
  $("#flashBtn").addEventListener("click", async ()=>{ try{ await connectWallet(); await startFlashLoan(); }catch(e){ console.error(e); alert(e?.data?.message||e?.message||e); } });

  $("#rpcPill").textContent="RPC: Alchemy (wired)";
  $("#tokensPill").textContent="Tokens: "+TOKENS.length;
  const box=$("#execContract"); if(box && /^0x[a-fA-F0-9]{40}$/.test(DEFAULT_EXECUTOR_ADDR)) box.value=DEFAULT_EXECUTOR_ADDR;
}
if(document.readyState==="loading") document.addEventListener("DOMContentLoaded", wireUI); else wireUI();

/* Account/network listeners */
if (window.ethereum) {
  window.ethereum.on("accountsChanged",(a)=>{ if(a && a[0]){ const fee=$("#feeWallet"); if(fee) fee.value=a[0]; log("ℹ️ Account changed: "+a[0]); }});
  window.ethereum.on("chainChanged",()=>window.location.reload());
}
</script>
</body>
</html>
