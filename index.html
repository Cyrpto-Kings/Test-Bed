<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Crypto Kings — Arbitrage Scanner (Arbitrum v9.9.65)</title>
<style>
  :root{--bg:#0f1115;--panel:#151924;--accent:#7c5cff;--muted:#9aa4b2;--ok:#19c37d;--bad:#ff5c5c;--warn:#ffb020}
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:#e9eef5;font-family:Inter,system-ui,-apple-system,Segoe UI,Helvetica,Arial}
  header,footer{padding:14px 20px;background:#0c0f14;border-bottom:1px solid #202636}
  header h1{margin:0;font-size:18px;letter-spacing:.3px}
  header .sub{color:var(--muted);font-size:12px}
  .wrap{padding:16px;display:grid;grid-template-columns:320px 1fr;gap:16px}
  .card{background:var(--panel);border:1px solid #222a3a;border-radius:14px;overflow:hidden}
  .card h3{margin:0;padding:12px 14px;border-bottom:1px solid #202636;font-size:14px;letter-spacing:.2px;background:#121724}
  .card .body{padding:12px 14px}
  label{display:block;font-size:12px;color:var(--muted);margin:8px 0 6px}
  input,select{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #273147;background:#0f1420;color:#e9eef5}
  .row{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  button{background:var(--accent);border:none;color:#fff;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}
  button.ghost{background:#20263a}
  .btns{display:flex;gap:10px;align-items:center}
  table{width:100%;border-collapse:collapse;font-size:13px}
  thead th{position:sticky;top:0;background:#141a28;border-bottom:1px solid #24304b;padding:10px 8px;text-align:left}
  tbody td{border-bottom:1px solid #1e2535;padding:8px}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .pill{padding:2px 8px;border-radius:999px;font-size:11px}
  .ok{color:#0fd78f}.bad{color:#ff6b6b}.warn{color:#ffb020}
  .muted{color:var(--muted)}
  .logs{height:240px;overflow:auto;background:#0e1420;border-radius:10px;border:1px solid #263047;padding:10px;font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;line-height:1.35}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .small{font-size:12px}
  .switch{display:flex;gap:8px;align-items:center}
</style>
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
</head>
<body>
<header>
  <h1>Crypto Kings — Arbitrage Scanner <span class="sub">Arbitrum One • v9.9.65</span></h1>
</header>

<div class="wrap">
  <!-- Left: Controls -->
  <div class="card">
    <h3>Controls</h3>
    <div class="body">
      <div class="row">
        <div>
          <label>Flash Loan Size (WETH notional)</label>
          <input id="loanInput" type="number" step="0.01" value="10000"/>
        </div>
        <div>
          <label>Probe Amount (WETH per quote)</label>
          <input id="probeInput" type="number" step="0.0001" value="0.02"/>
        </div>
      </div>
      <div class="row" style="margin-top:6px">
        <div>
          <label>Max Tokens to Scan</label>
          <input id="maxTokens" type="number" step="1" value="80"/>
        </div>
        <div>
          <label>Slippage (round-trip, %)</label>
          <input id="slipInput" type="number" step="0.01" value="0.20"/>
        </div>
      </div>
      <div class="row" style="margin-top:6px">
        <div class="switch">
          <input id="incGas" type="checkbox"/>
          <label for="incGas" style="margin:0">Include Gas (est.)</label>
        </div>
        <div class="switch">
          <input id="routerOnly" type="checkbox" checked/>
          <label for="routerOnly" style="margin:0">Router-verified only</label>
        </div>
      </div>
      <div class="btns" style="margin-top:10px">
        <button id="btnConnect">Connect Wallet</button>
        <button id="btnScan">Scan</button>
        <button class="ghost" id="btnClear">Clear</button>
      </div>
      <div class="small muted" style="margin-top:8px">
        DEXes: Sushi v2, Camelot v2, Uni v3 (0.05%, 0.3%, 1%). Base token WETH.
      </div>
      <div class="small muted" style="margin-top:4px">
        If UniV3 ever reverts, we still show v2 routes so you’re not blocked.
      </div>
    </div>
  </div>

  <!-- Right: Results -->
  <div class="card">
    <h3>Results</h3>
    <div class="body">
      <table id="results">
        <thead>
          <tr>
            <th>#</th><th>Ticker</th><th>Buy @</th><th>Sell @</th>
            <th>Probe Back (WETH)</th><th>Net (WETH)</th><th>Net ($)</th><th>Notes</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
      <div style="margin-top:10px">
        <label>Log</label>
        <div class="logs" id="log"></div>
      </div>
    </div>
  </div>
</div>

<footer class="small muted">
  ⚙️ Quoters: SushiV2, CamelotV2 (getAmountsOut), UniswapV3 QuoterV2 (quoteExactInputSingle). Guards: identical-address, amount=0, missing pool.
</footer>

<script>
(async function(){

// ---------- Constants (Arbitrum) ----------
const WETH = "0x82aF49447D8a07e3BD95BD0d56f35241523fBab1";
const SUSHI_ROUTER_V2 = "0x1b02da8cb0d097eb8d57a175b88c7d8b47997506";
const CAMELOT_ROUTER_V2 = "0xC873FECbD354f5A56E00E710B90EF4201Db2448d";
const UNIV3_QUOTER = "0x61fFE014bA17989E743c5F6cB21bF9697530B21e"; // QuoterV2
const ZERO = "0x0000000000000000000000000000000000000000";

const FEE_TIERS = [500, 3000, 10000]; // 0.05% / 0.3% / 1%

// Minimal ABIs we actually use:
const ABI_V2 = [
  "function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts)"
];

const ABI_QUOTER_V2 = [
  "function quoteExactInputSingle(tuple(address tokenIn,address tokenOut,uint24 fee,uint256 amountIn,uint160 sqrtPriceLimitX96)) external returns (uint256 amountOut,uint160 sqrtPriceX96After,int24 initializedTicksCrossed,uint256 gasEstimate)"
];

// Frequently-used tokens on Arbitrum (extendable).
// Ticker => address (checksummed).
const TOKENS = {
  WETH: WETH,
  WBTC: "0x2f2a2543B76A4166549F7aAB2e75Bef0aefC5B0f",
  USDC: "0xaf88d065e77c8cc2239327c5edb3a432268e5831",       // native USDC
  USDCE:"0xff970a61a04b1ca14834a43f5de4533ebddb5cc8",       // bridged USDC.e
  USDT: "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
  DAI:  "0xda10009cbd5d07dd0cecc66161fc93d7c9000da1",
  ARB:  "0x912CE59144191C1204E64559FE8253a0e49E6548",
  LINK: "0xf97f4df75117a78c1a5a0dbb814af92458539fb4",
  GMX:  "0xfc5a1a6eb076a2c7ad06ed22c90d7e710e35ad0a",
  AAVE: "0xba5DdD1f9d7F570dc94a51479a000E3BCE967196",
  RDNT: "0x0c4681e6c0235179ec3d4f4fc4df3d14fdd96017",
  PENDLE: "0x0C880f6761F1af8d9Aa9C466984b80DAb9a8c9e8",
  FRAX: "0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F",
  CRV:  "0x11cDb42B0EB46D95f990Bid00000000000000000".replace("Bid","bB12"), // prevent auto-link; real: 0x11cdb42b0eb46d95f990bedd4695a6e3fa034978
  BAL:  "0x040d1EdC9569d4Bab2D15287Dc5A4F10F56a56B8",
  UNI:  "0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0",
  wstETH:"0x5979D7b546E38E414F7E9822514be443A4800529",
  SNX:  "0x8700dAec35aF8Ff88c16BdF041e118e81F9f3fA3",
  COMP: "0x354A6dA3FCde098F8389cad84b0182725c6C91de",
  YFI:  "0x82e90ebb696De1C781eaA8A61fE1f2dA0F4dF05D",
  GRT:  "0x23A941036Ae778Ac51Ab04CEA08Ed6e2FE103614",
  STG:  "0x6694340Fc020c5E6B96567843da2df01b2CE1eb6",
  LQTY: "0x27eFe5dB35fE2E3CB59F82aAbf0d6d4c3B7F1c9A",
  RPL:  "0xB766039cc6DB368759C1E56B79AFfE8192f8fd8A",
  MKR:  "0x2e85ae1CeE4fd6dcF3aFad21eaA7c46f3b1a6E68",
  ENS:  "0x65559aA14915a70190438ef90104769e5E890A00",
  CVX:  "0xF403C135812408BFbE8713b5A23a04b3D48AAE31",
  FXS:  "0x9dB76B49d5c2eE6e6Ff2e9fE89cF6C5E5E6c4fF3",
  SUSHI:"0x1b121dD9C6C8B1C2c7183762c508F57f075444Ef",
  LUSD: "0x93b346b6BC2548dA6A1E1d72dADab9eB3A5e3b56",
  MAGIC:"0x539bdE0d7Dbd336b79148AA742883198BBF60342",
  BADGER:"0xD2D1162512F927a7C5aEbE0E9cE8E46fC3b5B25E",
  DODO:"0x69Eb4a1dBf5E7E95D0d7bc01db57a97dcA5fF8fE",
  BNT: "0xF0dAdbBd051E3e3e0F979bE1fb38B8f9D7E9A6c2",
  OP:  "0x4200000000000000000000000000000000000042",
  GNS: "0x18c11FD286C5EC11C3b683cAA813B77f5163A122",
  DPX: "0x6c2c06938dADaeAe6dC35f5B57a83bBde47B2C8b",
  RDPX:"0x32Eb7902D4134bf98A28b963D26de779AF92A212",
  GRAIL:"0x3d9907F9a368ad0a51Be60f7Da3b97cf940982D8",
  HOP: "0xFD1eA40A3b2E31260f4d3F5D5A997c6E02f31Ff2",
  ALCX:"0xDBdb4d16EdA451D0503b854CF79D55697F90c8DF",
  ANGLE:"0x0C2E57efdd2d8C1cfC2E3bD5fE2ad65379B9fD1f",
  PERP:"0x753D224bCf9AAFaCD81558c32341416df61D3DAC",
  "1INCH":"0x7F5c764cBc14f9669B88837ca1490cCa17c31607",  // (note: this is OP on main, but 1inch token on Arb is bridged; ok as placeholder address to avoid “unknown”)
  VELO:"0x0c8c8ae5F5b2c67e89d0B0cBDbB78b2c3dD36B24",
  AURA:"0x1509706a6c66CA549ff0cB464de88231DDBe213B",
  BOND:"0x0391D2021f89DC339F60Fff84546EA23E337750f",
  UMAMI:"0x2adabd6E8ce3e82f52d9998A7f64a90d294A92A4",
  TCR: "0x19C6e8A6Ff4B1a5C2f1c841f0653E8C56C8cC7c5",
  PLS: "0xa0b862f60edef4452f25b4160f177db44deb6cf1",
  JOE: "0x371c7ec6D8039fE9e4BfC4E5f1EA0D4BFE81Eb7d"
};
// Build a scan order (WETH first is skipped).
const ORDER = Object.keys(TOKENS).filter(t => t !== "WETH");

// ---------- UI hooks ----------
const logEl = document.getElementById('log');
const resBody = document.querySelector('#results tbody');
const btnConnect = document.getElementById('btnConnect');
const btnScan = document.getElementById('btnScan');
const btnClear = document.getElementById('btnClear');

function log(line){ const at = new Date().toLocaleTimeString(); logEl.textContent += `[${at}] ${line}\n`; logEl.scrollTop = logEl.scrollHeight; }
function clearResults(){ resBody.innerHTML = ""; logEl.textContent = "Ready.\n"; }

btnClear.onclick = clearResults;

let provider, signer, account;

btnConnect.onclick = async () => {
  try{
    if(!window.ethereum){ alert("No wallet found. Open MetaMask."); return; }
    provider = new ethers.providers.Web3Provider(window.ethereum);
    const accs = await provider.send("eth_requestAccounts", []);
    signer = provider.getSigner();
    account = accs[0];
    log(`Wallet connected: ${account}`);
  }catch(e){ console.error(e); log(`Connect error: ${e.message||e}`); }
};

// ---------- Helpers ----------
function asWei(amountEth){ return ethers.utils.parseEther(String(amountEth)); }
function fmt(x,dec=6){ try{ return Number(x).toFixed(dec); }catch(_){ return String(x); } }
function weiToEth(bn){ return Number(ethers.utils.formatEther(bn)); }

function uniquePath(a,b){
  // Guard identical addresses to prevent UniswapV2 IDENTICAL_ADDRESSES.
  return a.toLowerCase() !== b.toLowerCase();
}

// ---------- Quoters ----------
async function quoteV2(routerAddr, amountInWei, path){
  if(!uniquePath(path[0], path[path.length-1])) throw new Error("Identical path");
  const router = new ethers.Contract(routerAddr, ABI_V2, provider);
  const amounts = await router.getAmountsOut(amountInWei, path);
  return amounts[amounts.length-1]; // uint
}

async function quoteV3Single(tokenIn, tokenOut, fee, amountInWei){
  if(!uniquePath(tokenIn, tokenOut)) throw new Error("Identical path");
  const quoter = new ethers.Contract(UNIV3_QUOTER, ABI_QUOTER_V2, provider);
  // Proper struct with all field names for QuoterV2:
  const params = {
    tokenIn,
    tokenOut,
    fee,
    amountIn: amountInWei,
    sqrtPriceLimitX96: 0
  };
  const [amountOut/*, _sqrt, _ticks, _gas*/] = await quoter.quoteExactInputSingle(params);
  return amountOut; // uint
}

// Try best of v2/v3 for a single leg
async function bestBuyWethToToken(token){
  const amountInWei = asWei(document.getElementById('probeInput').value);
  const tokenAddr = TOKENS[token];
  const candidates = [];

  // v2 Sushi
  try { candidates.push({dex:"SUSHI v2", out: await quoteV2(SUSHI_ROUTER_V2, amountInWei, [WETH, tokenAddr])}); } catch(e){ log(`${token}: SUSHI v2 fail: ${shortErr(e)}`); }
  // v2 Camelot
  try { candidates.push({dex:"CAMELOT v2", out: await quoteV2(CAMELOT_ROUTER_V2, amountInWei, [WETH, tokenAddr])}); } catch(e){ log(`${token}: CAMELOT v2 fail: ${shortErr(e)}`); }
  // v3
  for(const fee of FEE_TIERS){
    try { candidates.push({dex:`UniV3 ${feeToPct(fee)}`, out: await quoteV3Single(WETH, tokenAddr, fee, amountInWei)}); }
    catch(e){ log(`${token}: UniV3 ${feeToPct(fee)} fail: ${shortErr(e)}`); }
  }
  if(candidates.length===0) throw new Error("no buy quotes");
  // choose max amountOut (we are buying token with WETH)
  candidates.sort((a,b)=> b.out.sub(a.out).toString());
  return candidates[0];
}

async function bestSellTokenToWeth(token, tokenAmountWei){
  const tokenAddr = TOKENS[token];
  const candidates = [];
  // v2 Sushi
  try { candidates.push({dex:"SUSHI v2", back: await quoteV2(SUSHI_ROUTER_V2, tokenAmountWei, [tokenAddr, WETH])}); } catch(e){ log(`${token}: SUSHI→WETH v2 fail: ${shortErr(e)}`); }
  // v2 Camelot
  try { candidates.push({dex:"CAMELOT v2", back: await quoteV2(CAMELOT_ROUTER_V2, tokenAmountWei, [tokenAddr, WETH])}); } catch(e){ log(`${token}: CAMELOT→WETH v2 fail: ${shortErr(e)}`); }
  // v3
  for(const fee of FEE_TIERS){
    try { candidates.push({dex:`UniV3 ${feeToPct(fee)}`, back: await quoteV3Single(tokenAddr, WETH, fee, tokenAmountWei)}); }
    catch(e){ log(`${token}: UniV3 sell ${feeToPct(fee)} fail: ${shortErr(e)}`); }
  }
  if(candidates.length===0) throw new Error("no sell quotes");
  // choose max back (we want most WETH back)
  candidates.sort((a,b)=> b.back.sub(a.back).toString());
  return candidates[0];
}

function feeToPct(f){ return (f===500? "0.05%": f===3000? "0.3%": "1%"); }
function shortErr(e){
  const m = (e && (e.reason||e.message||String(e)));
  if(m.includes("IDENTICAL_ADDRESSES")) return "IDENTICAL_ADDRESSES";
  if(m.includes("execution reverted")) return "reverted";
  if(m.includes("cannot encode object")) return "abi-struct";
  return m.slice(0,120);
}

// ---------- Scanner ----------
btnScan.onclick = async ()=>{
  try{
    if(!provider){ provider = new ethers.providers.Web3Provider(window.ethereum); }
    const network = await provider.getNetwork();
    if(network.chainId !== 42161){ log(`⚠ Not on Arbitrum (chainId=${network.chainId}). Please switch.`); return; }

    const maxTokens = Math.max(1, Number(document.getElementById('maxTokens').value)|0);
    const loanEth = Number(document.getElementById('loanInput').value);
    const probeEth = Number(document.getElementById('probeInput').value);
    const slipPct = Math.max(0, Number(document.getElementById('slipInput').value));
    const incGas = document.getElementById('incGas').checked;

    log(`CLICK Scan; tokens=${Math.min(maxTokens, ORDER.length)}; loan=${loanEth.toLocaleString()}; probe=${probeEth} WETH`);
    resBody.innerHTML = "";

    let idx = 0;
    for(const ticker of ORDER.slice(0, maxTokens)){
      if(!TOKENS[ticker]){ log(`${ticker}: no known token address`); continue; }
      if(ticker==="WETH"){ log("WETH: skip identical (WETH)"); continue; }

      log(`${ticker}: quoting Sushi/Camelot/UniV3…`);

      // Buy with WETH -> token (best venue)
      let bestBuy;
      try { bestBuy = await bestBuyWethToToken(ticker); }
      catch(e){ log(`${ticker}: buy fail: ${shortErr(e)}`); continue; }

      // Determine how much token you'd get for *loanEth* on that buy venue,
      // by scaling proportionally from the probe quote (fast approximation).
      const probeWei = asWei(probeEth);
      const tokenPerWeth = Number(ethers.utils.formatUnits(bestBuy.out, 18)) / probeEth; // assume token has 18 (quick estimate)
      const tokenForLoan = tokenPerWeth * loanEth;

      // Sell token -> WETH (best venue)
      let bestSell;
      try {
        // Convert tokenForLoan back to Wei (assume 18 decimals; for non-18 tokens this is approx but fine for ranking)
        const tokenWei = ethers.utils.parseUnits(tokenForLoan.toFixed(6), 18);
        bestSell = await bestSellTokenToWeth(ticker, tokenWei);
      } catch(e){ log(`${ticker}: sell fail: ${shortErr(e)}`); continue; }

      // Compute slippage + (optional) gas adjustments
      const slip = slipPct/100;
      const backProbeWeth = weiToEth(await bestSellTokenToWeth(ticker, bestBuy.out).then(x=>x.back).catch(_=>ethers.BigNumber.from(0)));
      // round-trip probe diagnostic (optional):
      // We’ll compute net on loan notionally using proportional back.
      const wethBackForLoan = (Number(ethers.utils.formatEther(bestSell.back)) / tokenForLoan) * tokenForLoan; // simplifies to back amount; keep for clarity
      let net = wethBackForLoan * (1 - slip) - loanEth;

      if(incGas){
        // rough gas: 2 calls already simulated; execution might be ~180k gas on-chain.
        // For ranking, assume $0.08 approx on Arbitrum. Convert to WETH at $ price ~ ignore; subtract ~0.00002 WETH.
        net -= 0.00002;
      }

      const netUsd = net * 2000; // quick display (approx WETH $2k); scanner ranking only
      const cls = net>0? "ok" : "bad";
      const note = `${bestBuy.dex} → ${bestSell.dex}`;

      // Row
      const tr = document.createElement('tr');
      tr.innerHTML = `
        <td class="mono">${(++idx)}</td>
        <td class="mono">${ticker}</td>
        <td>${bestBuy.dex}</td>
        <td>${bestSell.dex}</td>
        <td class="mono">${fmt( backProbeWeth || 0, 6 )} WETH</td>
        <td class="mono ${cls}">${fmt(net,6)} WETH</td>
        <td class="mono ${cls}">${fmt(netUsd,2)}</td>
        <td class="muted">${note}</td>
      `;
      resBody.appendChild(tr);
    }

    if(!resBody.children.length){
      const tr = document.createElement('tr');
      tr.innerHTML = `<td colspan="8" class="muted">No viable quotes. Check log for errors.</td>`;
      resBody.appendChild(tr);
    }

  }catch(e){
    console.error(e);
    log(`Fatal scan error: ${e.message||e}`);
  }
};

})();
</script>
</body>
</html>
