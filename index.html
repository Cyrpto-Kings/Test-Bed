<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Crypto Kings TestBed v9.8.0</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
<style>
  body{margin:0;font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;background:#f6f7f9;color:#111}
  header{background:#111;color:#fff;padding:12px 16px;display:flex;justify-content:space-between;align-items:center}
  h1{font-size:18px;margin:0}
  .wrap{max-width:1000px;margin:0 auto;padding:20px}
  .controls{background:#fff;border:1px solid #ddd;border-radius:12px;padding:16px;margin-bottom:20px}
  label{font-size:13px;color:#555;display:block;margin-top:8px}
  input{padding:8px;border:1px solid #ccc;border-radius:8px;width:100%;font-size:14px}
  button{margin-top:12px;padding:10px 16px;border:none;border-radius:8px;background:linear-gradient(135deg,#7c5cff,#1d9bf0);color:#fff;font-weight:600;cursor:pointer}
  table{width:100%;border-collapse:collapse;margin-top:20px;background:#fff}
  th,td{padding:8px 10px;border-bottom:1px solid #eee;font-size:13px;text-align:left}
  th{background:#fafafa;font-weight:600}
  .right{text-align:right}
  .ok{color:#10b981}
  .bad{color:#ef4444}
  #status{margin-top:12px;font-size:13px;color:#555}
  #log{margin-top:20px;padding:10px;font-size:12px;max-height:200px;overflow:auto;background:#fff;border:1px solid #ddd;border-radius:8px}
</style>
</head>
<body>
<header>
  <h1>Crypto Kings v9.8.0 — Arbitrum</h1>
  <div id="walletStatus">Wallet: Not connected</div>
</header>
<div class="wrap">
  <div class="controls">
    <label for="loanAmount">Loan Amount (USDC)</label>
    <input id="loanAmount" type="number" value="10000" min="100" step="100"/>
    <button id="scanBtn">Scan Opportunities</button>
    <div id="status"></div>
  </div>
  <div id="resultsWrap">
    <table id="results">
      <thead>
        <tr>
          <th>Token</th>
          <th>Buy DEX</th>
          <th class="right">Buy Out</th>
          <th>Sell DEX</th>
          <th class="right">Sell Out</th>
          <th class="right">Spread %</th>
          <th class="right">Net P/L (USDC)</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>
  </div>
  <div id="log"></div>
</div>

<script>
(async function(){
  const $=id=>document.getElementById(id);
  const provider = new ethers.providers.JsonRpcProvider("https://arb1.arbitrum.io/rpc");
  const USDC = "0xaf88d065e77c8cC2239327C5EDb3A432268e5831";

  // Some token list (expandable; top liquid)
  const TOKENS = {
    WETH:"0x82af49447d8a07e3bd95bd0d56f35241523fbab1",
    ARB:"0x912CE59144191C1204E64559FE8253a0e49E6548",
    USDT:"0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
    DAI:"0xda10009cbd5d07dd0cecc66161fc93d7c9000da1",
    GMX:"0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a",
    MAGIC:"0x539bde0d7dbd336b79148aa742883198bbf60342",
    GNS:"0x18c11fd286c5ec11c3b683caa813b77f5163a122",
    RDNT:"0x3082cc23568ea640225c2467653db90e9250aaa0"
  };

  // Uniswap v3 quoter (Arbitrum)
  const UNI_QUOTER = "0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6";
  const quoterAbi = ["function quoteExactInputSingle(address tokenIn,address tokenOut,uint24 fee,uint256 amountIn,uint160 sqrtPriceLimitX96) external returns (uint256 amountOut)"];
  const uniQuoter = new ethers.Contract(UNI_QUOTER, quoterAbi, provider);

  // SushiSwap router
  const SUSHI_ROUTER = "0x1b02da8cb0d097eb8d57a175b88c7d8b47997506";
  const routerAbi = ["function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts)"];
  const sushiRouter = new ethers.Contract(SUSHI_ROUTER, routerAbi, provider);

  // Camelot router
  const CAMELOT_ROUTER = "0xc873fEcbd354f5A56E00E710B90EF4201db2448d";
  const camelotRouter = new ethers.Contract(CAMELOT_ROUTER, routerAbi, provider);

  async function uniQuote(tokenAddr, amountIn){
    try{
      const out = await uniQuoter.callStatic.quoteExactInputSingle(USDC, tokenAddr, 500, amountIn, 0);
      const back = await uniQuoter.callStatic.quoteExactInputSingle(tokenAddr, USDC, 500, out, 0);
      return {buyOut:out, sellOut:back};
    }catch(e){return null;}
  }
  async function routerQuote(router, tokenAddr, amountIn){
    try{
      const buyPath=[USDC,tokenAddr];
      const sellPath=[tokenAddr,USDC];
      const out = await router.getAmountsOut(amountIn, buyPath);
      const back= await router.getAmountsOut(out[1], sellPath);
      return {buyOut:out[1], sellOut:back[1]};
    }catch(e){return null;}
  }

  async function scan(){
    const amt=parseFloat($("loanAmount").value||"0");
    if(!(amt>0)){ alert("Enter loan amount"); return; }
    const amountIn=ethers.utils.parseUnits(String(amt),6); // USDC has 6 decimals
    $("status").textContent="Scanning tokens… this may take a minute";
    $("rows").innerHTML="";
    let logs=[];
    for(const [sym,addr] of Object.entries(TOKENS)){
      $("status").textContent=`Scanning ${sym}…`;
      const uni=await uniQuote(addr, amountIn);
      const sushi=await routerQuote(sushiRouter, addr, amountIn);
      const camel=await routerQuote(camelotRouter, addr, amountIn);
      const dexes={};
      if(uni) dexes.Uniswap=uni;
      if(sushi) dexes.Sushi=sushi;
      if(camel) dexes.Camelot=camel;
      const entries=Object.entries(dexes);
      if(entries.length<2) continue;
      // find best buy (max tokenOut) and best sell (max USDC back)
      let best=null;
      entries.forEach(([dex,q])=>{
        const spread=(Number(q.sellOut)-amt*1e6)/(amt*1e6);
        if(!best || spread>best.spread){
          best={buyDex:dex,sellDex:dex,spread,net:Number(q.sellOut)/1e6-amt};
        }
      });
      // Actually compare across DEXes: buy lowest cost, sell highest return
      let maxSell=-Infinity, minBuy=Infinity, buyDex=null, sellDex=null;
      entries.forEach(([dex,q])=>{
        if(q.buyOut && Number(q.buyOut)<minBuy){minBuy=Number(q.buyOut);buyDex=dex;}
        if(q.sellOut && Number(q.sellOut)>maxSell){maxSell=Number(q.sellOut);sellDex=dex;}
      });
      if(maxSell>0 && minBuy<Infinity){
        const spread=(maxSell-minBuy)/minBuy;
        const net=(maxSell/1e6)-amt; // USDC decimals
        if(net>0){
          const tr=document.createElement("tr");
          tr.innerHTML=`<td>${sym}</td>
            <td>${buyDex}</td><td class="right">${(minBuy/1e18).toFixed(6)}</td>
            <td>${sellDex}</td><td class="right">${(maxSell/1e6).toFixed(2)}</td>
            <td class="right">${(spread*100).toFixed(2)}%</td>
            <td class="right ${net>0?'ok':'bad'}">${net.toFixed(2)}</td>`;
          $("rows").appendChild(tr);
        }
      }
    }
    $("status").textContent="Scan complete";
  }
  $("scanBtn").addEventListener("click",scan);
})();
</script>
</body>
</html>
